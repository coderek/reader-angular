{"etag": "", "title": "云风的 BLOG", "last_modified": [2017, 4, 11, 2, 50, 14, 1, 101, 0], "entries": [{"summary": "<p>我们公司有两个项目的客户端在使用 git 做项目管理，三个项目使用 svn 管理。程序员比较爱 git ，但是为什么 svn 还存在？主要是在做客户端开发时，策划和美术人员始终迈不那道坎。即使已经在用 git 的项目，策划们还是反应用起来比 svn 跟容易犯错误，遇到自己无法解决的问题也更多。 我是非常想在公司全部推广使用 git 做项目管理的。所以需要仔细考察到底是什么东西阻止了策划（及美术）们掌握这个工具。 思考一番后，我认为一套完整的培训机制还是得建立起来。完全靠自学和口口相传是不靠谱的。尤其是在有 svn 基础的时候，非程序开发人员接受 git 其实比程序开发人员要困难的多。如果你硬要把 svn 的概念全部适配到 git 上，其实就是在把 git 当 svn 在用，不仅获得不了好处，反而增加了很多困扰。 而实用主义者，在没有外力的情况下，只会看到表面。不可能系统的从原理上系统理解 git 到底解决了什么问题、每步操作背后到底做了什么，如果出现了问题，问题是怎么引起的。我们知道，在用 git 的时候，由于分支和提交都比 svn 方便，分布式的结构也会更容易导致版本演化图变得异常复杂。当它乱成一团乱麻的时候，任何新的合并操作都会比之前遇到更多麻烦。如果使用者心里有清晰的概念，时刻保持演化关系简单，他遇到的问题自然会少。而你遇到问题乱解决一通，只满足于把现在的问题搞定，那么下次就会面临更大的灾难。...</p>", "title": "为什么美术和策划在使用 git 时会遇到更多麻烦", "published": [2017, 4, 10, 15, 47, 9, 0, 100, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/04/git.html", "content": "<div><p>我们公司有两个项目的客户端在使用 git 做项目管理，三个项目使用 svn 管理。程序员比较爱 git ，但是为什么 svn 还存在？主要是在做客户端开发时，策划和美术人员始终迈不那道坎。即使已经在用 git 的项目，策划们还是反应用起来比 svn 跟容易犯错误，遇到自己无法解决的问题也更多。</p>\n\n<p>我是非常想在公司全部推广使用 git 做项目管理的。所以需要仔细考察到底是什么东西阻止了策划（及美术）们掌握这个工具。</p>\n\n<p>思考一番后，我认为一套完整的培训机制还是得建立起来。完全靠自学和口口相传是不靠谱的。尤其是在有 svn 基础的时候，非程序开发人员接受 git 其实比程序开发人员要困难的多。如果你硬要把 svn 的概念全部适配到 git 上，其实就是在把 git 当 svn 在用，不仅获得不了好处，反而增加了很多困扰。</p>\n\n<p>而实用主义者，在没有外力的情况下，只会看到表面。不可能系统的从原理上系统理解 git 到底解决了什么问题、每步操作背后到底做了什么，如果出现了问题，问题是怎么引起的。我们知道，在用 git 的时候，由于分支和提交都比 svn 方便，分布式的结构也会更容易导致版本演化图变得异常复杂。当它乱成一团乱麻的时候，任何新的合并操作都会比之前遇到更多麻烦。如果使用者心里有清晰的概念，时刻保持演化关系简单，他遇到的问题自然会少。而你遇到问题乱解决一通，只满足于把现在的问题搞定，那么下次就会面临更大的灾难。</p>\n\n        <p>过去在网易，我们建立了一套培训机制。入职开发人员（至少是所有校招人员），无论是做策划还是程序还是美术，都必须经过 svn 的培训。只有建立其版本管理的概念，日后工作中才会少犯错误。</p>\n\n<p>而从基本概念上讲，git 其实并不比 svn 复杂多少，缺少的正是这套流程。让使用者知其然也知其所以然。</p>\n\n<hr>\n\n<p>今天我自己做了一份材料，晚上尝试对部分同事做了两个小时的讲座。材料其实不重要，网上可以找到比我做的详细的多，好的多的教程。重要的是互动教学的部分。听的人可以讲出自己的疑惑，然后立刻得到解答。</p>\n\n<p>我最想教授的就是 git 根本的原理，而操作这些反而是次要的。因为你不记得的时候总可以在网上搜索到。</p>\n\n<hr>\n\n<p>首先，我觉得最关键、也是最容易被学习者遗漏的是，git 是有工作区、暂存区、历史记录（仓库）三个区域的。而 svn 只有工作区和中心服务器的仓库两个，没有暂存区。如果只记几个操作，完全不用知道这些，硬去背操作就好了。但是出了问题就容易懵。</p>\n\n<p>我们平常工作的文件，都是在工作区修改。这和 svn 并没有什么不同，也不需要特别讲解。但是，一旦工作做到一个段落，需要提交到大家共享的仓库，情况就变得不同了。</p>\n\n<p>暂存区实际可以勉强看成 svn （图形化界面）的那个提交面板上的多选框。svn 和它的前辈 cvs 最大的不同就是文件是做成一个集合同时提交的，提交是原子性的，要么一起成功，要么一起失败。而 cvs 是基于单个文件的。所以我们需要把提交声明成一个集合。</p>\n\n<p>svn 采用的方法是在提交时勾选，而 git 采用的是设立一个中间容器，可以用 git add , git rm ,git mv 逐步把想修改的东西复制进去，然后在生成提交集的时候原子性搞定。由于提交总是针对本地仓库，就总是成功；而 svn 针对是远程仓库，有可能失败。</p>\n\n<p>git 允许大家协作时共享的数据保存在不同的地方，只要数据严格相同，就认为是同一份数据。这个设计允许每个创作人员有最大的自主性，因为你可以在这份数据上任意修改（包括开设分支），只在最后要和别人同步的时候再同步。但是坏处就是，事实上每个人的那份共享数据又各不相同，这是因为大家的同步时机不可能相同。</p>\n\n<p>我们要获得创作自主性这个好处的同时，就必须承担手动同步共享数据这个责任。也就是 fetch merge (pull) push 这些操作。这些操作在用 svn 时是不存在的，用 git 时，如果你不了解上面的细节，自然也容易忘记。</p>\n\n<p>同样，reset checkout revert merge 等等都是在对三个区之间挪动数据的不同操作。如果不去理解操作指针、不去理解工作区和暂存区的关系，应去记 git reset --hard 可以回退版本，远程仓库的回退要 revert ，碰到冲突时就无法理解问题是怎么产生的。</p>\n\n<p>而概念其实不那么理解，需要的只是认真去了解。</p>\n\n<hr>\n\n<p>我个人认为， git 的本质就在于管理好版本演化的图。图的每个节点，也就是 commit 意味着一组对文件的修改。commit 和 commit 的关系就是谁在谁基础上做的修改，构成了节点间的连线。git 的复杂点在于，每个 commit 都可能基于多个 commit 生成的，让这些节点不再是一条直线连接。</p>\n\n<p>这个复杂性还是为了解决更灵活的，从任何一个位置衍生创作这个需求。表现在 git 里就是无限制的开分支。</p>\n\n<p>分支对协作开发非常的重要，因为开发人员总需要自己试验点什么而不需要和别人达成默契（不需要把修改推送到中央服务器）；总有开发团体中的部分人间的协作，而不想影响到另一部分人；长期维护的项目总有各种不同的版本需要同时维护……</p>\n\n<p>灵活的分支是 git 和 svn 根本性的不同，它也带来了开发流程上的革新，所谓支持分布式开发只是一点点副作用而已。</p>\n\n<hr>\n\n<p>所以每个使用者也都有责任维护好整个项目的 commits 构成的图不要失控，乱成一团。</p>\n\n<p>为什么策划和美术更容易遇到麻烦？</p>\n\n<p>我想，所谓麻烦，都是和 merge 有关，也就是要重新连接图上面无关的两个（多个）节点时需要做的事情。merge 就是把图上两个节点用一个新节点连起来，然后后面的人就可以从一个统一点开始i继续演化。这里面就包括了把节点对应的数据内容合理的融合在一起，而不光是连个线。</p>\n\n<p>融合的算法基础叫做三路合并。也就是，当你想让 A 和 B 合成一个时，版本管理器会去追寻 A 和 B 之前是在哪里分开的。大多数情况下可以找到一个公共的节点 C 。我们就可以认为 A 路线和 B 路线在走到 C 之前是完全一致的，我们不用理会，要做的是让 C 到 A 与 C 到 B 殊途同归。</p>\n\n<p>由于每个修改集是有更零碎的针对单个文件的修改，我们检查 A 和 B 中，如果有和 C 中相同的文件；</p>\n\n<ol>\n<li>那么如果三个版本完全一致，这个文件就保持原样就够了，因为 A 和 B 都没有修改过。</li>\n<li>如果 A 和 B 中的文件版本都和 C 不一致，但是 A 和 B 的版本之间又是相同的，那么它们的修改是一样的，就取改过的就好了。</li>\n<li>如果只有 A 和 C 不一致，或只有 B 和 C 不一致；那么就认为只有一方修改，那么取修改的一方即可。</li>\n<li>冲突发生在这里，A B C 分别是完全不同的三个版本，这就要留给人来决策。</li>\n</ol>\n\n<p>当文件是纯文本的时候，内容其实是按行分成更小的单位的。我们可以理解成是更细碎的小块。所以即使发生了 4 ，大部分情况下，分得更细的块之间依然可以自动处理好分歧。</p>\n\n<p>但是策划一般用 excel word 这种二进制格式，美术更是以二进制图片模型数据为主。享受不到拆分更细的自动消除分歧过程，需要手工处理的东西更多。</p>\n\n<p>不过通常，这也不是大问题。策划可以简单的用使用我的版本或使用他的版本，在 A B 中二择，帮助系统完成三路合并。</p>\n\n<hr>\n\n<p>那么困扰策划们的问题出在哪里呢？我认为是 “交叉合并” 的情况。也就是需要合并的 A 和 B 并没有简单的一个分差点 C ，而是多个。git 在处理这种情况有多套方案，默认的是递归处理。把合并问题转换为一个个三路合并的子问题。在解决子问题的过程中，很可能就需要多次的寻求人的帮助确认。简单的单次用我的版本或用你的版本很容易犯错。</p>\n\n<p>我一下找不到合适的实际例子，随便编一个，可能不太合理，姑且看看：</p>\n\n<p>如果一开始的一处 commit 修改了 A B C  ，我们把它的版本叫做 A0B0C0 。然后，版本推进到了下一个版本，修改了 AB 没有动 C ，版本变成了 A1B1C0 。</p>\n\n<p>这个时候，两个人分别在 A1B1C0 的基础上做跟进，甲改了 B1 成 B2 ，乙改了 C0 成 C1 。我们看到的版本演化大致是这样的：</p>\n\n<pre>\nA0B0C0 ------- A1B1C0 +------- A1B2C0(甲)\n                      +------- A1B1C1(乙)\n</pre>\n\n<p>这时候，在 A0B0C0 上发现了一个 bug ，有人修复了。修复涉及到 B 和 C 的修改，这样就产生了 B3 和 C2 。我们暂把 A0B3C2 这个版本成为 bugfix 分支。</p>\n\n<pre>\nA0B0C0 +------ A1B1C0 +------- A1B2C0(甲)\n       |              +------- A1B1C1(乙)\n       +------ A0B3C2(bugfix)\n</pre>\n\n<p>这时，甲和乙都知道这个 bug 修改了，他们都把这个 bugfix 合到了自己的分支上。三路合并的结果是 A 保留了版本 A1 ，甲发现 B 被两者都改了，他在 B2 和 B3 的基础上创作了新的 B4 ；乙除了要在 B1 和 B3 的基础上创作出 B5，还发现发现 C 也都改了，就在 C1 和 C2 的基础上创作了 C3 。</p>\n\n<p>现在版本图就成了这样：</p>\n\n<pre>\nA0B0C0 +------ A1B1C0 +------- A1B2C0(甲) ---------------A1B4C2\n       |              +------- A1B1C1(乙)------A1B5C3       |\n       |                                       /            |\n       +------ A0B3C2(bugfix)-----------------/-------------+\n</pre>\n\n<p>甲和乙的版本，也就是 A1B4C2 和 A1B5C3 要合并的那一刻，问题就不再是简单的三路合并了。因为这两个版本有两个共同的根：A1B1C0 和 A0B3C2 。</p>\n\n<p>如果是甲来处理合并，他会非常疑惑。因为再次之前，甲并没有修改过 C ，他手头上的 C2 是在之前和 bugfix 分支三路合并自动合过来的。他当时并没有在意。但是现在他要处理 A1B4C2 和 A1B5C3  两个版本汇总的 C2 (bugfix 带过来) 和 C3 的冲突了。而 C 文件似乎并没有经过他的修改。</p>\n\n<hr>\n\n<p>在这个例子里，烦恼的核心在于 bugfix 被分别合并到了两个分支上，这个合并过程，甲和乙做起来都不难，顺手就搞定了。但是在最后甲和乙做大合并时，埋下的炸弹才爆炸。</p>\n\n<p>如果在开发过程中，不断的这种随意合并，一开始冲突比较好解决；但是积累多了以后，就变成了选择难题。</p>\n\n<p>程序员比较少碰到这种选择难题，我想是因为：</p>\n\n<ol>\n<li><p>程序员即使是对待开发路径上比较顺利的 merge 过程，也会比较谨慎的审核，心里对变更跟有底。而文本合并更容易看到差异全貌，也方便了做这种审核。所以问题比较少累积。</p></li>\n<li><p>即使是并非自己经手的数据文件，最终的合并行为也可以单独的被正确处理，而不是只有使用我们的，使用他们的一条路。</p></li>\n<li><p>文本文件可以被拆分的更细，往往系统就把差异处理好了，不必抛给人来审查。</p></li>\n</ol></div>", "uuid": "tag:blog.codingnow.com,2017://1.1044+http://blog.codingnow.com/2017/04/git.html"}, {"summary": "<p>我们公司的一个 MMORPG 项目最近在内存方面碰到了红线，昨天开会讨论了一下。我提出了一个改进方案，写篇 blog 记录一下。 问题是这样的。在当下的手机及平板硬件设备条件下，操作系统留给应用的可用内存并不多，大约只有 500M 左右。 和 PC 环境不同，手机上是交换分区的机制来对应一些临时突发性内存需求的。而手机必须保证一些系统服务（某些高优先级后台业务）的运行，所以在接电话、收取推送等等意外任务发生时，有可能多占用一些内存，导致操作系统杀掉前台任务让出资源。 根据实际测试，游戏想跑在当前主流高端手机上必须把自己的内存占用峰值控制在 400M 内存以下，350 M 会是一个合理的值，而这个值是远远低于 10 年前的 PC 游戏标准的。而我们的项目却是一个写实类型的 拥有大场景的 MMORPG 。...</p>", "title": "Unity3D 的大场景内存优化", "published": [2017, 4, 6, 2, 26, 20, 3, 96, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/04/unity3d_memory.html", "content": "<div><p>我们公司的一个 MMORPG 项目最近在内存方面碰到了红线，昨天开会讨论了一下。我提出了一个改进方案，写篇 blog 记录一下。</p>\n\n<p>问题是这样的。在当下的手机及平板硬件设备条件下，操作系统留给应用的可用内存并不多，大约只有 500M 左右。</p>\n\n<p>和 PC 环境不同，手机上是交换分区的机制来对应一些临时突发性内存需求的。而手机必须保证一些系统服务（某些高优先级后台业务）的运行，所以在接电话、收取推送等等意外任务发生时，有可能多占用一些内存，导致操作系统杀掉前台任务让出资源。</p>\n\n<p>根据实际测试，游戏想跑在当前主流高端手机上必须把自己的内存占用峰值控制在 400M 内存以下，350 M 会是一个合理的值，而这个值是远远低于 10 年前的 PC 游戏标准的。而我们的项目却是一个写实类型的 拥有大场景的 MMORPG 。</p>\n\n        <p>Unity3D 是在智能手机普及以前设计的，远没有料到会被广泛用于手机游戏的制作。它在设计之初并没有为低内存环境考虑。内存使用太粗犷，是在使用 Unity 开发 MMORPG 项目时最被吐槽的一点。</p>\n\n<p>为手机游戏定制游戏引擎，最特别的，和 PC 游戏不同的两点就是内存必须严格控制、能耗必须严格控制。比如在我们开发的 ejoy2d 中，会为资源数据中的项目引用定制短指针，即资源内部的相互引用使用 32bit 偏移量来代替 64bit 指针，每个指针节省出 4 字节内存；变换矩阵使用 6 个 32bit 的定点数，资源中相同矩阵共享一份数据；资源数据尽量连续存放，避免小数据块太多造成内存碎片浪费内存等等。这些显然是 Unity 没花精力去做的。在 PC 上，省下几M 几十M 内存微不足道，但在手机上很可能就是生死之间。</p>\n\n<p>ps. 能耗问题是另一个有趣点。在 PC 上你可以通过多线程并行，压榨出高 fps ，可以不管 CPU 多烫；但是到了手机上，即使 CPU 8 核心已经是标配，还是尽量不要这么做。因为在总任务相同的情况下，单线程能做完的工作只要拆分到多线程上完成，就一定意味着总工作量增加（至少增加了线程间协调的工作）。增加了总能耗。玩家是不想玩一个插着充电线也会玩关机，手机滚烫的游戏的。这个问题有机会我另写一篇 blog 展开，今天是想谈谈内存。</p>\n\n<hr>\n\n<p>在我们最近的测试中，在较坏情况下，我们的游戏会占到 360M 内存左右，已经接近了内存红线，所以要考虑进一步的优化。其中，较大的一块是游戏场景，占了 120M 内存。</p>\n\n<p>有趣的是，这 120M 内存中只有大约 50M 是用于场景上物件的贴图、模型等等资源数据（注：我们项目没有使用静态批次合并，那样更消耗内存。）；也就是说，有 70M 内存用于构建场景本身的结构。所以，并非让美术人员尽量复用同样模型的花花草草就可以省下内存的。换句让美术人员更容易明白的说法，我们的场景中摆的东西太多了，不是减少贴图用量，把同一块石头到处摆可以解决的。这和过去制作 PC 游戏的常识不同。</p>\n\n<p>所以，大部分现有的手机 MMORPG 的画风偏卡通幻想风格不是没有道理。因为那样，可以用有悖现实的物件比例，场景物件个头大，就可以用更少的数量去充斥场景。而写实风讲将就细节丰富，用诸多细节去填满视野。在过去 PC 上，这不是问题，只要少做点独特的模型，少用贴图就能把内存降下来，手机上不行了。</p>\n\n<hr>\n\n<p>我们并非刚刚意思到这点。一开始，开发人员就针对大场景制定了技术解决方案。</p>\n\n<p>我们在场景上，认为设定了若干包围盒，勾画出一块块小区域。一旦玩家离开包围盒太远，程序就会把包围盒里面的物件卸载出内存。然后在美术设计上，不让玩家有可以从远处观望的角度。我们的美术风格会尽量保证场景细而精致、不追求空旷宏大的场面。</p>\n\n<p>但这还做的不够，我提出了一个改进方案。</p>\n\n<hr>\n\n<ol>\n<li><p>保留包围盒方案。但是包围盒略微扩大，允许包围盒重叠，并可以用多个包围盒来定义一个区域。同一个场景物件只可以属于一个区域，即使它的位置在多个区域内。（区域可以重叠）</p></li>\n<li><p>所有物件都标记分类出外观物件和细节物件。比如一个城市的城墙就是外观物件，而城内的所有东西都是细节物件；一片树林的大颗植物是外观物件，地面的花花草草是细节物件。一般情况下，大部分物件都默认是细节物件，只有少数需要远观的才标记成外观。这点，其实原本就做了视距分层，只不过是为了在渲染时做显示剔除用的，并没有用于控制内存。而这次，需要对外观物件和细节物件单独打包分类，便于分开卸载。</p></li>\n<li><p>当玩家处于一个区域内部时，必须保证这个区域的外观物件和细节物件都加载到内存。如果之前并不在内存，也需要开启异步加载的流程。当一个玩家距离另一个区域比较近时，只需要确保该区域的外观物件在内存即可，可以卸载任何不在区域的细节物件。</p></li>\n</ol>\n\n<hr>\n\n<p>在以上改进方案里，把包围盒扩大以及允许多个包围盒一起构成区域，是为了改进数据加载的时机。单一用距离判断会有瑕疵。比如在城墙外，即使隔的很近也不需要加载城内的细节。而我们完全可以在城门外加一个缓冲的小区域并入城市区域，只要玩家一踩到城门口，城内的细节加载流程就开始启动了。</p>\n\n<p>而允许区域重叠，并让物件唯一归属于单一区域则可以解决城门外的细节物体提前加载时机。城外的这块缓冲区上的物件就不必归属到城市板块，它们早在玩家在城外活动时就加载完毕了。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1043+http://blog.codingnow.com/2017/04/unity3d_memory.html"}, {"summary": "<p>skynet 在最初的设计里，希望做一个分布式系统，抹平 actor 放在本机和处于网络两端的差别。所以，设计了 master/slave 模式。利用 4 个字节表示 actor 的地址，其高 8 位是节点编号，低 24 位是进程（节点）内的 id 。这样，在同一个系统中，不管处于哪个进程下，每个 actor （在 skynet 中被成为服务）都有唯一的地址。在投递消息时，无需关心目的地是在同一个进程内，还是通过网络来投递消息。 随后，我发现试图抹平网络和本地差异的想法不那么靠谱。想把一个分布式系统做得（和单一进程同样）可靠，无论如何都简单不了。而 skynet 的核心希望可以保持简单稳定。所以我打算把分布式的支持放在稍上一点的层次实现。 先来说说同一进程下的服务通讯和跨网络的通讯到底有什么不同。 进程内的内存是共享的，skynet 是用 lua 沙盒来隔离服务状态，但是可以通过 C 库来绕过沙盒直接沟通。如果一个服务生产了大量数据，想传给您一个服务消费，在同一进程下，是不必经过序列化过程，而只需要通过消息传递内存地址指针即可。这个优化存在 O(1) 和 O(n) 的性能差别，不可以无视。 同一进程内的服务从底层角度来说，是同生共死的。Lua 的沙盒可以确保业务错误能够被正确捕获，而非常规代码不可控的错误，比如断电、网络中断，不会破坏掉系统的一部分而另一部分正常工作。所以，如果两个 actor 你确定在同一进程内，那么你可以像写常规程序那样有一个共识：如果我这个 actor 可以正常工作，那么对端协作的另一个...</p>", "title": "skynet  cluster 模块的设计与编码协议", "published": [2017, 3, 25, 7, 41, 8, 5, 84, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/03/skynet_cluster.html", "content": "<div><p>skynet 在最初的设计里，希望做一个分布式系统，抹平 actor 放在本机和处于网络两端的差别。所以，设计了 master/slave 模式。利用 4 个字节表示 actor 的地址，其高 8 位是节点编号，低 24 位是进程（节点）内的 id 。这样，在同一个系统中，不管处于哪个进程下，每个 actor （在 skynet 中被成为服务）都有唯一的地址。在投递消息时，无需关心目的地是在同一个进程内，还是通过网络来投递消息。</p>\n\n<p>随后，我发现试图抹平网络和本地差异的想法不那么靠谱。想把一个分布式系统做得（和单一进程同样）可靠，无论如何都简单不了。而 skynet 的核心希望可以保持简单稳定。所以我打算把分布式的支持放在稍上一点的层次实现。</p>\n\n<p>先来说说同一进程下的服务通讯和跨网络的通讯到底有什么不同。</p>\n\n<ol>\n<li><p>进程内的内存是共享的，skynet 是用 lua 沙盒来隔离服务状态，但是可以通过 C 库来绕过沙盒直接沟通。如果一个服务生产了大量数据，想传给您一个服务消费，在同一进程下，是不必经过序列化过程，而只需要通过消息传递内存地址指针即可。这个优化存在 O(1) 和 O(n) 的性能差别，不可以无视。</p></li>\n<li><p>同一进程内的服务从底层角度来说，是同生共死的。Lua 的沙盒可以确保业务错误能够被正确捕获，而非常规代码不可控的错误，比如断电、网络中断，不会破坏掉系统的一部分而另一部分正常工作。所以，如果两个 actor 你确定在同一进程内，那么你可以像写常规程序那样有一个共识：如果我这个 actor 可以正常工作，那么对端协作的另一个 actor 也一样在正常工作。就等同于，我这个函数在运行，我当然可以放心的调用进程内的另一个函数，你不会担心调用函数不存在，也不会担心它永远不返回或是收不到你的调用。这也是为什么我们不必为同一进程内的服务间 RPC 设计超时的机制。不用考虑对方不相应你的情况，可以极大的简化编写程序的人的心智负担。比如，常规程序中，就没有（非 IO 处理的）程序库的 API 会在调用接口上提供一个超时参数。</p></li>\n<li><p>同一进程内所有服务间的通讯公平共享了同一内存总线的带宽。这个带宽很大，和 CPU 的处理速度是匹配的。可以基本不考虑正常业务下的服务过载问题。也就是说，大部分情况下，一个服务能生产数据的速度不太会超过另一个服务能消费数据的速度。这种情况会造成消费数据的服务过载，是我们使用 skynet 框架这几年来 bug 出现最多的类型。而跨越网络时，不仅会因为生产速度和消费速度不匹配造成过载，更会因为传递数据的带宽和生产速度不匹配而过载。如果让开发者时刻去考虑，这些数据是投递到本地、那些数据是投递到网络，那么已经违背了抹平本地和网络差异这点设计初衷。</p></li>\n</ol>\n\n<p>所以我认为，除非你的业务本来就是偏重 IO 的，也就是你根本不打算利用单台硬件的多核心优势来增强计算力，抹平本机和网络的差异是没有意义的。无论硬件怎样发展，你都不可能看到主板上的总线带宽和 TCP 网络的带宽工作在同一数量级的那一天，因为这是物理基本规律决定的。</p>\n\n<p>当你的业务需要高计算力，把 actor 放在一台机器上才可以正常的发挥 CPU 能力去合作；如果你的系统又需要分布式扩展，那么一定是有很多组独立无关的业务可以平行处理。这两类工作必须由构架系统的人自己想清楚，规划好怎么部署这些 actor ，而不可能随手把 actor 扔在分布式系统中，随便挑台硬件运行就够了。</p>\n\n<p>恰巧网络游戏服务就是这种业务类型。多组服务器、多个游戏场景之间交互很弱，但其中的个体又需要很强的计算力。这就是 skynet 切合的应用场景。</p>\n\n        <hr>\n\n<p>我在 skynet 的核心层之上，设计了 cluster 模块。它大部分用 lua 编写，只有通讯协议处理的部分涉及一个很小的 C 模块。用 Lua 编写可以提高系统的可维护性，和网络通讯的带宽相比，Lua 相对 C 在处理数据包的性能降低是微不足道的。</p>\n\n<p>它的工作原理是这样的：</p>\n\n<p>在每个 skynet 节点（单个进程）内，启动一个叫 clusterd 的服务。所有需要跨进程的消息投递都先把消息投递到这个服务上，再由它来转发到网络。</p>\n\n<p>在 cluster 集群中的每个节点都使用一个字符串来命名，由一个配置表来把名字关联到 ip 地址和端口上。理论上同一个 skynet 进程可以监听多个消息入口，只要用名字区分开，绑定在不同的端口就可以了。</p>\n\n<p>为了和本地消息做区分，cluster 提供了单独的库及一组新的 API ，这个库是对 clusterd 服务通讯的浅封装。当然，也允许建立一个代理服务，把代理服务它收到的消息，绑上指定名字，转发到 clusterd 。这样就和之前的 master/slave 模式几乎没有区别了。</p>\n\n<p>在 skynet 1.0 版中，是不支持 cluster.send 的。也就是不能直接向 cluster 单向推送消息，而必须使用 cluster.call 也就是请求回应方式。这么做是考虑以下几个因素：</p>\n\n<ol>\n<li><p>推送实质上是可以用请求回应替代的，因为你可以简单忽略掉回应。如果担心 call 操作阻塞住执行流程，那么可以使用 skynet.fork 来调用 cluster.call ，或是另外写一个服务来代理推送。即，向这个服务 send 消息，让代理服务来阻塞调用。</p></li>\n<li><p>cluster 有一个显式的网络过程，我希望使用者可以明白这一点，而不是把它藏起来。对于网络推送，就必然存在失败的可能：对方节点宕机、tcp 连接意外断开（这在云主机上尤其常见）都有可能发送不到，所以必须有一个回应机制来反馈这种异常。固然可以实现一套可靠的不丢消息的消息队列，但我认为应该在更高的层次来做，否则为保证消息队列的可靠性而做出的性能损失以及实现复杂度的提升是不太划算的。而 cluster.call 则可以直接抛出 error 通知调用者失败，用的人清晰了解这种失败的可能性，迫使用的时候做出失败处理逻辑。而 cluster.send 从 api 设计上就无法留这个余地。</p></li>\n</ol>\n\n<p>但近一年的实践表明，无论是我们自己公司的人使用、还是第三方 skynet 用户，都迫切的需要 cluster.send 语义，这使我对上面的想法做出妥协，打算在 skynet 1.1 中正式引入 cluster.send 。</p>\n\n<hr>\n\n<p>最初的实现比较随意。打算在原有基础上打个小补丁，尽量对老代码和流程不做修改。所以我扩展了 skynet.ret 的实现，让它可以根据消息的 session 是否为 0 来判断是不是一个单向推送（send），如果不需要返回则什么都不做。这样，只要约定，任何消息都写上 skynet.ret 回应，由框架来决定是否真的要回应就好了。这样，cluster.send 依旧利用 cluster.call 去请求，对方对于跨节点的推送也可以做出回应。发起请求方再把回应包扔掉即可。</p>\n\n<p>换句话说，cluster 间的通讯协议并没有修改，无论是 cluster.call 还是 cluster.send 都是发起的一样的网络请求，都要求对方回应。一个服务在响应本地推送消息时，调用 skynet.ret 会直接忽略；而响应网络推送时，是经由 clusterd 转发过来的请求，（由于协议限制，clusterd 无法区分是一个推送还是一个请求），skynet.ret 则做出一个回应。最后回应包会转回发起方时被扔掉。</p>\n\n<p>最开始用这个模式来使用 cluster.send 的同学，由于了解整个历史，所以理解并接受这个用法。但新同学还是容易漏掉这处细节。skynet.send 和 cluster.send 的这个小区别确实挺让人意外的，我也不认为在文档中写清楚就够了，毕竟大部分人是不读文档的。为了遵循最小意外原则，我打算修正 cluster 通讯协议，明确区分 send 和 call 的网络包。</p>\n\n<p>下面记录一下 cluster 通讯协议编码，以备日后查阅。通过了解编码协议，也能理解为什么在 cluster 通讯层次上，光靠判断 session 是否为 0 来区分推送和请求包是不够的。</p>\n\n<p>在 cluster 间的一条 TCP 连接上，两端是严格分为请求方和回应方。比如 A 发起连接到 B ，那么只能是 A 向 B 提出请求，B 回应它；如果 B 想向 A 发起请求的话，需要由 B 向 A 再建立一条通道。</p>\n\n<p>请求协议是这样编码的：</p>\n\n<p>首先是两个字节的包头，高位在第一个字节、低位在第二个字节。采用大端编码是和 skynet 的 gate 模块一致。</p>\n\n<p>第三个字节是一个 type ，可以区分这是一个小的完整包，还是一个大包的一部分；请求地址是 32bit id 还是一个字符串。</p>\n\n<p>type 为 0 ，表示这是一个不超过 32K 字节的完整包，目的地址是一个 32bit id 紧跟在后面第 4 到 7 字节。接下来 8 到 11 字节是 session 号；如果 session 为 0 表示这是一个推送包，不需要回应；否则需要根据 session 来匹配回应包。12 字节开始就是包的内容。</p>\n\n<p>type 为 1 或 0x41 ，表示这是一个超过 32K 字节的请求(1)或推送(0x41)，这个包本身没有数据内容，只有地址、sesson 和包的总长度。分别以此编码在后面 12 字节内。其中长度采用的是小端编码的 32bit 数字。</p>\n\n<p>type 为 0x80 ，和 0 类似，但地址是一个字符串而不是 32bit 的 id 。字符串最长不超过 255 字节，用一个字节的长度加字符串内容编码在原来 4 字节 id 的位置。</p>\n\n<p>type 为 0x81 或 0xc1 时，对应 1 和 0x41 ，只是把地址从 id 换为字符串。</p>\n\n<p>type 为 2 或 3 时，表示这是一个长消息中的一部分。包内容为 4 字节的 session 和具体的数据。 2 表示还有后续的数据，3 表示这是最后一段数据。</p>\n\n<p>回应的编码协议简单一些：</p>\n\n<pre>\nWORD size (big endian)\nDWORD session\nBYTE type\n    0: error\n    1: ok\n    2: multi begin\n    3: multi part\n    4: multi end\nPADDING msg\n    type == 0, error msg\n    type == 1, msg\n    type == 2, DWORD size\n    type == 3/4, msg\n</pre>\n\n<hr>\n\n<p>这里，超过 32K 的数据包需要分成小包传输，而分开的小包依赖 session 来区隔，所以必须让每组长消息都有唯一 session 。这样就必须额外在 type 字段来区分是请求还是推送。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1042+http://blog.codingnow.com/2017/03/skynet_cluster.html"}, {"summary": "<p>skynet 1.0 于 2016 年 8 月 1 日正式发布，到今天已经有 7 个多月了。这段时间积累了很多小修改，我想是时候发布 1.1 版了。 很高兴这段时间 skynet 社区继续壮大，有更多的公司选择基于 skynet 开发。 现打算在下个月以目前 github 仓库 master 分支为基础发布 1.1 正式版，这两周如果同学们还有什么问题请尽快提 issue 。 下面是从 1.0 开始积累的更新：...</p>", "title": "skynet 1.1 发布候选版本", "published": [2017, 3, 20, 4, 6, 2, 0, 79, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/03/skynet_1_1_rc.html", "content": "<div><p>skynet 1.0 于 2016 年 8 月 1 日正式发布，到今天已经有 7 个多月了。这段时间积累了很多小修改，我想是时候发布 1.1 版了。</p>\n\n<p>很高兴这段时间 skynet 社区继续壮大，有更多的公司选择基于 skynet 开发。</p>\n\n<p>现打算在下个月以目前 github 仓库 master 分支为基础发布 1.1 正式版，这两周如果同学们还有什么问题请尽快提 issue 。</p>\n\n<p>下面是从 1.0 开始积累的更新：</p>\n\n        <ul>\n<li>debug console : 可用户指定绑定 ip 。</li>\n<li>debug console : 增加 call 指令向服务发送消息。</li>\n<li>debug console : 反馈 inject code 的错误信息。</li>\n<li>debug console : 修改命令确认信息，方便自动化处理。</li>\n<li>sharedata : 增加 flush 。</li>\n<li>sharedata : 增加 deepcopy 。</li>\n<li>cluster : 增加 send 。</li>\n<li>cluster : 支持绕过配置文件直接传递配置表。</li>\n<li>skynet : 增加 state 指令查询服务的 cpu 开销。</li>\n<li>skynet : wakeup 保证次序。</li>\n<li>httpc : 支持 timeout 。</li>\n<li>mongo driver :  sort 支持多个 key 。</li>\n<li>bson : 对 string 类型做 utf8 编码检查。</li>\n<li>daemon 模式 : 可正确输出错误信息。</li>\n<li>sproto : 支持定点数。</li>\n<li>sproto: 支持 binary 类型。</li>\n<li>jemalloc : 更新到 4.5.0</li>\n<li>lua : 更新到 5.3.4</li>\n</ul>\n\n<p>还有一些次要的 bugfix 及代码调整没有列出。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1041+http://blog.codingnow.com/2017/03/skynet_1_1_rc.html"}, {"summary": "<p>又一篇谈 Lua debugger 的 blog 了。但这次，并不是我的个人作品 :) 。 去年底我写了 如何优雅的实现一个 lua 调试器 。正如我的 blog 中所写：“不过期待它短期内发展成为一个图形式的漂亮交互调试器可能有点不现实，除非做前端的朋友有兴趣来完善它。” ok 。这次，真的有人来完善它了。 我公司的前端大神突然对实现一个 lua debugger 产生了兴趣。他觉得既然 chrome 可以用来调试 javascript ，那么魔改一下后，调试 lua 也完全没有问题。利用几个月的业余时间，他完成了这么个东西： http://mare.ejoy.com/ ps. 不愧是做前端出身啊，开源项目的主页比 skynet 好看多了。...</p>", "title": "Lua 调试器", "published": [2017, 3, 17, 7, 38, 3, 4, 76, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/03/lua_debugger.html", "content": "<div><p>又一篇谈 Lua debugger 的 blog 了。但这次，并不是我的个人作品 :) 。</p>\n\n<p>去年底我写了 <a href=\"http://blog.codingnow.com/2016/11/lua_debugger.html\">如何优雅的实现一个 lua 调试器</a> 。正如我的 blog 中所写：“不过期待它短期内发展成为一个图形式的漂亮交互调试器可能有点不现实，除非做前端的朋友有兴趣来完善它。”</p>\n\n<p>ok 。这次，真的有人来完善它了。</p>\n\n<p>我公司的前端大神突然对实现一个 lua debugger 产生了兴趣。他觉得既然 chrome 可以用来调试 javascript ，那么魔改一下后，调试 lua 也完全没有问题。利用几个月的业余时间，他完成了这么个东西：</p>\n\n<p><a href=\"http://mare.ejoy.com/\">http://mare.ejoy.com/</a></p>\n\n<p>ps. 不愧是做前端出身啊，开源项目的主页比 skynet 好看多了。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1040+http://blog.codingnow.com/2017/03/lua_debugger.html"}, {"summary": "<p>sproto 是我设计的一个类 google protocol buffers 的东西。 在很多年前，我在我经手的一些项目中使用 google protocol buffers 。用了好几年，经历了几个项目后，我感觉到它其实是为静态编译型语言设计的协议，其实并没有脱离语言的普适性。在动态语言中，大家都不太愿意使用它（json 更为流行）。一个很大的原因是，protobuffers 是基于代码生成工作的，如果你不使用代码生成，那么它自身的 bootstrap 就非常难实现。 因为它的协议本身是用自身描述的，如果你要解析协议，必须先有解析自己的能力。这是个先有鸡还是先有蛋的矛盾。过去很多动态语言的 binding 都逃不掉引入负责的 C++ 库再加上一部分动态代码生成。我对这点很不爽，后来重头实现了 pbc 这个库。虽然它还有一些问题，并且我不再想维护它，这个库加上 lua 的 binding 依然是 lua 中使用 protobuffer 的首选。...</p>", "title": "sproto 的一些更新", "published": [2017, 3, 14, 13, 38, 55, 1, 73, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/03/sproto_new_feature.html", "content": "<div><p><a href=\"http://blog.codingnow.com/2014/07/sproto.html\">sproto</a> 是我设计的一个类 google protocol buffers 的东西。</p>\n\n<p>在很多年前，我在我经手的一些项目中使用 google protocol buffers  。用了好几年，经历了几个项目后，我感觉到它其实是为静态编译型语言设计的协议，其实并没有脱离语言的普适性。在动态语言中，大家都不太愿意使用它（json 更为流行）。一个很大的原因是，protobuffers 是基于代码生成工作的，如果你不使用代码生成，那么它自身的 bootstrap 就非常难实现。</p>\n\n<p>因为它的协议本身是用自身描述的，如果你要解析协议，必须先有解析自己的能力。这是个先有鸡还是先有蛋的矛盾。过去很多动态语言的 binding 都逃不掉引入负责的 C++ 库再加上一部分动态代码生成。我对这点很不爽，后来重头实现了 <a href=\"http://blog.codingnow.com/2011/12/protocol_buffers_for_c.html\">pbc</a> 这个库。虽然它还有一些问题，并且我不再想维护它，这个库加上 lua 的 binding 依然是 lua 中使用 protobuffer 的首选。</p>\n\n        <p>protobuffer 自身有很长的历史，历史带来了包袱，实际上在我放弃 protobuffer 后不久，google 也大刀阔斧的更新了 3.0 版，对之前 2.x 版做了很多必要的，不兼容的改进。</p>\n\n<p>我仿照 protobuffer 的基本理念设计了 sproto ，设计上的考虑在之前的 blog 中已经写了很多。</p>\n\n<p>sproto 的设计理念之一：保证基本能用的基础上足够简单，不增加太多特性。如果要增加新特性，都是仔细考虑过，并保持不破坏兼容性。最近一段时间，我给 sproto 加了两个特性，这里简单介绍一下：</p>\n\n<p>其一，sproto 没有内置的浮点数类型。因为我觉得大多数项目中，传输浮点数的必要性都不大。如果必须传输的话，可以用字符串，或二进制串来替代。由传输的双方来共同约定保证一致性。</p>\n\n<p>但是，有时候传输小数的需求依然存在。我认为定点数可以是一种选择，而且不必破坏原有的协议，也不必增加新的类型。只需要在 sproto 的协议描述中加一些备注。</p>\n\n<p><a href=\"http://blog.codingnow.com/2015/03/sproto_unordered_map.html\">之前给 sproto 加字典支持就是靠备注实现的</a>。</p>\n\n<p>这次我选择在 integer 类型后面加一个备注，比如写 integer(2) 就表示，这个整数类型是一个有两位十进制小数位的定点数。两端在解析同样的协议时，需要在编码的时候 * 100 取整再编码，解码的时候 /100 还原。</p>\n\n<p>如果有一端使用老版本的实现，那么可以在跟上层自行乘除 100 来兼容。</p>\n\n<p>第二，sproto 用 string 类型来传输字符串和二进制串。它可以自然对应到 lua 中的 string 类型。但是，很多其它语言中，可阅读的 string 和 binary 串是两种不同的类型。其 string 类型需要额外指定编码。</p>\n\n<p>sproto 缺乏 binary 串的描述，会在 python c# 等语言中遇到一些麻烦。</p>\n\n<p>考虑之后，我决定给 sproto 增加 binary 类型，但为了兼容，把它作为 string 的一个子类型实现。在新版的 sproto 中，你可以在协议文件中定义 binary 字段。但编码时，还是按 string 编码的，不会破坏兼容性。</p>\n\n<p>但新版本的代码在解码的时候，会根据协议定义，正确的通知 binding 层，这是一个 binary 串。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1039+http://blog.codingnow.com/2017/03/sproto_new_feature.html"}, {"summary": "<p>今天试了一下一个想法：绕过 lua 提供的 C API 直接去访问 lua 的表结构，提供在性能及其重要的环境高效访问数据结构的方法。 例如：我们需要在 lua 和 C 中共享一个 vector 3 结构，有两种实现方法：一、把 C struct 实现为 lua 中的 userdata ，然后给 userdata 加上 metatable 以供 lua 中访问内部数据；二、在 lua 中使用一个 table 实现这个 vector3 结构，类似 { x = 0.0 ,...</p>", "title": "绕过 c api 直接访问 lua 表", "published": [2017, 2, 21, 6, 12, 16, 1, 52, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/02/lua_direct_access_table.html", "content": "<div><p>今天试了一下一个想法：绕过 lua 提供的 C API 直接去访问 lua 的表结构，提供在性能及其重要的环境高效访问数据结构的方法。</p>\n\n<p>例如：我们需要在 lua 和 C 中共享一个 vector 3 结构，有两种实现方法：一、把 C struct 实现为 lua 中的 userdata ，然后给 userdata 加上 metatable 以供 lua 中访问内部数据；二、在 lua 中使用一个 table 实现这个 vector3 结构，类似 { x = 0.0 , y = 0.0, z = 0.0 } 这样；然后在 C 里通过 c api (<code>lua_rawget/lua_gettable/lua_getfield</code>) 来访问里面的数据。</p>\n\n<p>前一种方法会导致在 Lua 中访问成本加大、而后一种方法增加的是 C 中访问数据的成本。如果我们只在少数性能敏感的地方通过 C 去操作数据结构，那么第二种方法看起来更简单灵活一些。这样，不需要 C 介入的地方，是没有额外开销的。毕竟、通过 metamethod 索引 userdata 的成本比直接索引一个普通的 table 要重的多。</p>\n\n        <p>但是、第二种方法会导致 C 访问数据的成本较大。我们采用 C 代码去处理 vector 数据结构，一定是考虑到性能热点，在语言边界上损失性能感觉不太划算。我觉得或许可以采取一个技巧来加快它。</p>\n\n<p>对于标准的 Lua 实现，构造好的 hash 表，在不添加新 key 的前提下，读写已有的 key ，value 所在的 slot 是不变的。如果我们能记住 slot 的位置，那么就可以绕过 hash 过程、也不需要把 key （这里是一个 string）压栈，直接读写值了。</p>\n\n<p>而且，对于同一个 <code>lua_State</code> 从一个空表开始，按一致的次序写入相同的 key ，内部数据结构也一定相同。我们可以利用这一点，为同类结构一次性生成索引表。</p>\n\n<p>我写了一小段代码验证我的想法，感觉是可行的：<a href=\"https://gist.github.com/cloudwu/09fca725cb9177d809790b6a7ecdac20\">https://gist.github.com/cloudwu/09fca725cb9177d809790b6a7ecdac20</a> 。</p>\n\n<p>你可以先创建一个 4 个 slot 的 hash 表，key 分别是 x y z <code>__vector</code> 。这第 4 个 key <code>__vector</code> 是一个标记，表示这是个规整过的数据结构，x y z 都是浮点数，且一定在固定的 slot 里。</p>\n\n<p><code>void vector_init(lua_State *L, struct vector_offset *vo)</code> 可以用来生成 slot 号的结构 <code>struct vector_offset</code> 。每个 <code>lua_State</code> 只用生成一次，然后就可以永久保存在 C 的数据结构中。</p>\n\n<p>然后我们用 <code>vector_get</code> 可以获得内部数据结构 Table * ，这个结构定义在 lobject.h 中，是一个内部 h 文件，这里可以借用一下。之后，就可以用宏 X Y Z 去访问这个 Table * 了。</p>\n\n<p><code>vector_get</code> 中，会检查指定的 table 是否是规整化的 vector 结构，如果不是，就把 x y z 三项读出来，清空 table ，再写回去，并填上 <code>__vector</code> 标记。此处检查 <code>__vector</code> 标记是个很轻量的操作。</p>\n\n<hr>\n\n<p>这个方案适用于 Lua 5.3 ，我没有在老版本的 Lua 上试过，但想必也是可以用的。它的好处是不需要修改任何 Lua 的实现代码、只需要引入 Lua 本身的内部 h 文件即可。所以利用这组 api 实现的 lua 库是可以和其它库兼容共存的。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1036+http://blog.codingnow.com/2017/02/lua_direct_access_table.html"}, {"summary": "<p>今天同事在公司群里贴了张屏幕截图，上面有30+ 个盘。从 C: 排到 Z: , 然后还有 CC: CD: ，调侃问 Windows 能管理多少个盘。 图应该是 P 出来搞笑的，除去 A B 盘保留给已经淘汰的软驱用外，windows 超过 Z 盘后就不在能增加了。如果有更多储存设备，则需要用把设备挂接在空目录上（ntfs 支持）。 为什么 Windows 会有盘符这个诡异的东西呢？ 按如非必要、勿增实体的原则，只用路径就够了呀。物理分区完全可以隐藏在文件系统之后，在 Unix 系的操作系统中，分区是用挂接点的方式挂接在虚拟文件系统中的（ntfs 其实也支持）。如果是为了方便记忆和保持用户习惯，完全可以把分区顺着挂接到 /c /d /e /f 下。如果你在 windows 下安装 mingw/msys 它就是这样处理 C 盘、D...</p>", "title": "为什么 Windows 的文件系统会有盘符，使用反斜杠分割路径", "published": [2017, 2, 17, 6, 59, 39, 4, 48, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/02/windows_path_sep.html", "content": "<div><p>今天同事在公司群里贴了张屏幕截图，上面有30+ 个盘。从 C: 排到 Z: , 然后还有 CC: CD: ，调侃问 Windows 能管理多少个盘。</p>\n\n<p>图应该是 P 出来搞笑的，除去 A B 盘保留给已经淘汰的软驱用外，windows 超过 Z 盘后就不在能增加了。如果有更多储存设备，则需要用把设备挂接在空目录上（ntfs 支持）。</p>\n\n<p>为什么 Windows 会有盘符这个诡异的东西呢？</p>\n\n<p>按如非必要、勿增实体的原则，只用路径就够了呀。物理分区完全可以隐藏在文件系统之后，在 Unix 系的操作系统中，分区是用挂接点的方式挂接在虚拟文件系统中的（ntfs 其实也支持）。如果是为了方便记忆和保持用户习惯，完全可以把分区顺着挂接到 /c /d /e /f 下。如果你在 windows 下安装 mingw/msys 它就是这样处理 C 盘、D 盘 …… 的。</p>\n\n<p>答案要从历史中找。</p>\n\n        <p>Windows 的前身是 微软的 Dos 系统。我见过的最古老的 MS Dos 是在我同学家的一台旧 IBM PC/XT 上。10M 的硬盘、只有 256K 内存，配置的系统是 PC(MS) Dos 2.0 。</p>\n\n<p>知道这个 2.0 版的 Dos 比它的前身最大的改进是什么吗？它比 MS DOS 1.0 多支持了硬盘，以及层级目录结构。</p>\n\n<p>同时期的主流电脑是 Apple ][ ，它的原生操作系统（Apple Dos）是不支持硬盘的，软盘上只有一个根目录。MS Dos 1.0 也一样。</p>\n\n<p>除了 IBM PC，Apple ][ ，那个年代个人电脑品牌其实非常多。比如我的第一台电脑就是港产的 Z80 机器（laser 310 ）。当时 8 位机上最流行的个人操作系统是一个叫做 CP/M 的系统。不过当时流行直接用汇编写程序，这个 CP/M 必须跑在 Z80(8080)  的指令集上。当年 Apple ][ 上流行过一种叫做 Z80 卡的扩展件，就是为了可以跑 CP/M 系统。</p>\n\n<p>微软起家为 IBM 的 8086 系列 PC 写操作系统时，就借鉴了 CP/M 的一些东西，其中就有盘符这个东西。在没有硬盘，及内存小于软盘容量的年代，配置两个软盘驱动器是最方便的，所以就有了 A B 两个盘符（方便数据对拷）。每个文件都可以写成  A:FILENAME.EXT 的形式。这就是盘符的由来。</p>\n\n<p>btw, 早年 IBM 想和 CP/M 合作没谈成，后来 PC 流行后，CP/M 又反回来兼容了 MS-DOS 跑在 PC 系统上，改名字叫 DR-DOS ，应该很多同学有印象。</p>\n\n<p>MS DOS 发展到 2.0 时，由于 IBM 给 PC/XT 增加了 10M 的硬盘，所以盘符就被扩展到了 C: 表示硬盘。储存空间的增加导致了必须增加文件目录结构。可为啥微软选择了反斜杠，而不是 Unix 系列中已经很广泛的 / 呢？</p>\n\n<p>这是因为，MS Dos 已有的很多命令行工具。<a href=\"https://blogs.msdn.microsoft.com/larryosterman/2005/06/24/why-is-the-dos-path-character/\">当时微软做开发的人有 DEC 的背景</a>，DEC 的操作系统上是用 / 做命令行参数分割符，而不是 Unix 系列用的 - ，就这样沿用到了 MS Dos 里。btw， 我读大学时第一次接触 Linux ，感觉输入最不习惯的就是用 - 而不是 / 。</p>\n\n<p>为了防止混淆，目录风格符就不能再使用 / 了，DEC 系统中用的是点 \".\" ，可 MS Dos 学了 CP/M 用 . 做文件后缀名分割，所以就用了让后代程序员深恶痛绝的反斜杠 \\ 。</p>\n\n<p>ps. C 系列的语言中，\\ 是字符串转义符，写在字符串里你需要写 <code>\\\\</code> ，特别麻烦。</p>\n\n<hr>\n\n<p>今天发现本 Blog 用的虚拟主机 linode 降价了，现在只要 5$ 一个月。去后台调一下即可。<a href=\"http://blog.codingnow.com/2010/02/move.html\">Linode 用 7年了</a>，感觉非常好。</p>\n\n<p>如果有同学也有兴趣租一个境外的 vps ，可以<a href=\"http://www.linode.com/?r=538bab39bc1265a2ce54115d1f86e2bc81e4d133\">点这个链接</a> ，或者填我的 referral code : 538bab39bc1265a2ce54115d1f86e2bc81e4d133 。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1035+http://blog.codingnow.com/2017/02/windows_path_sep.html"}, {"summary": "<p>这两个月，我的主要工作是跟进公司内一个 MMORPG 项目，做一些代码审查提出改进意见的工作。 在数月前，项目经理反应程序不太稳定，经常出一些错误，虽然马上就可以改好，但是随着开发工作推进，不断有新的 bug 产生。我在浏览了客户端的代码后，希望修改一下客户端的 UI 框架以及消息分发机制等，期望可以减少以后的 bug 出生概率。由于开发工作不可能停下来重构，所以这相当于给飞行中的飞机换引擎，做起来需要非常小心，逐步迭代。 工作做了不少，其中一个小东西我觉得值得拿出来写写。 我希望 UI 部分可以严格遵守 MVC 模式来实现。其实道理都明白，但实际操作的时候，大部分人又会把这块东西实现得不伦不类。撇开各种条条框框，纸上谈兵的各种模式，例如 MVC MVP MVVM 这些玩意，我认为核心问题不在于 M 和 V 大家分不清楚，而是 M 和 V 产生联系的时候，到底应该怎么办。联系它们的是 C 还是 P 或是 VM 都只为解决一个问题：把 M 和 V 解耦。...</p>", "title": "跟踪数据结构的变更", "published": [2017, 2, 14, 6, 57, 17, 1, 45, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/02/tracedoc.html", "content": "<div><p>这两个月，我的主要工作是跟进公司内一个 MMORPG 项目，做一些代码审查提出改进意见的工作。</p>\n\n<p>在数月前，项目经理反应程序不太稳定，经常出一些错误，虽然马上就可以改好，但是随着开发工作推进，不断有新的 bug 产生。我在浏览了客户端的代码后，希望修改一下客户端的 UI 框架以及消息分发机制等，期望可以减少以后的 bug 出生概率。由于开发工作不可能停下来重构，所以这相当于给飞行中的飞机换引擎，做起来需要非常小心，逐步迭代。</p>\n\n<p>工作做了不少，其中一个小东西我觉得值得拿出来写写。</p>\n\n<p>我希望 UI 部分可以严格遵守 MVC 模式来实现。其实道理都明白，但实际操作的时候，大部分人又会把这块东西实现得不伦不类。撇开各种条条框框，纸上谈兵的各种模式，例如 MVC MVP MVVM 这些玩意，我认为核心问题不在于 M 和 V 大家分不清楚，而是 M 和 V 产生联系的时候，到底应该怎么办。联系它们的是 C 还是 P 或是 VM 都只为解决一个问题：把 M 和 V 解耦。</p>\n\n        <p>我们的底层使用的是 Unity3D 及它的 UGUI ，UGUI 提供了 UI 需要的显示控件对象，我们开发的业务逻辑则是围绕这些对象开发的。</p>\n\n<p>由于在移动设备上内存有限，项目又做了一系列的对象管理工作，UI 控件并不一定常驻内存，会根据需要加载或删除。又由于这是一个网络游戏，UI 操作和反馈经常需要和服务器打交道，又许多异步操作。故而有一段时间频发的 bug 来自于异步操作访问了被删除的控件对象。</p>\n\n<p>我认为其根本原因在于 M 和 V 没有很好的解耦。</p>\n\n<p>对于 UGUI 引擎提供的控件，应该完全封装在 View 中；而业务数据则应该全部放在和这些控件无关的数据结构即 Model 中。而 Model 改变引起的 View 更新逻辑，如果即不存在于 Model 的方法中，也独立于 View 之外的话，那么这类 Bug 应当是不会产生的。</p>\n\n<hr>\n\n<p>在迭代的代码中，我们要求 Model 必须是一个纯粹的数据结构，也不一定和显示（View）结构一一对应。比如玩家的 HP 在 Model 中只是一个字段，但可能反应在 View 里的多处地方；而 View 里某个呈现的状态也可以是 Model 中多个字段的复合结果。</p>\n\n<p>业务代码应该可以任意修改 Model ，不必关心 View 是否有效，理论上及时界面控件全部不存在，甚至是一个文本界面，代码也应该可以正常工作。修改 Model 的行为不需要立刻去更新 View ，即修改 M 和更新 V 不需要也不应该是一个同步行为。它们在框架中是两个明确独立的执行阶段，执行流程会清晰的多。</p>\n\n<p>这就类似网页前端，你的业务部分可以提交完整的网页 DOM ，然后浏览器更新 DOM 呈现成图像。当然，如果 UI 结构很复杂的话，每帧次都提交全新的完整 DOM 效率很低，如果可以筛选出每次的差异，根据差异来更新控件，效率就高的多了。</p>\n\n<hr>\n\n<p>去年底，我写了这么一个 lua 模块：<a href=\"https://github.com/cloudwu/tracedoc\">https://github.com/cloudwu/tracedoc</a></p>\n\n<p>它可以构造一张 lua 表对象，并跟踪对这张表的所有修改。调用 commit 方法可以比较和上次 commit 的版本间的差异，并生成差异集。</p>\n\n<p>这个差异是指的最终叶节点的值差异，比如如果原来的表里有一个字段是 a.x = { 1, 2} ；如果你重新写 a.x = {1, 2} 对 a.x 重新赋值，因为新的值还是 { 1, 2} ，模块会认为没有变化。</p>\n\n<p>在表里只可以存放 lua 原生数据类型：数字、字符串、布尔量。表内可以用 table 创建子结构，但子表的 key 只能是数字或字符串。表里也可以存放对象的引用，但必须用 table + metatable 的形式。所有带 metatable 的 table 都被识别为对象，不会递归比较内部细节。</p>\n\n<p>为了方便 UI 框架的使用，还允许使用者定义一组映射函数，当变更集变更的时候，调用变更数据节点在表内的路径串对应的预定义函数。</p>\n\n<p>这样，方便使用者实现对应的数据绑定特性。</p>\n\n<hr>\n\n<p>除了在 UI 框架中的应用，这个模块还可以用于 skynet 服务器服务间的数据同步。</p>\n\n<p>比如，我们可以为每个玩家创建一个 agent 服务管理玩家的数据，但多个玩家在一个场景中战斗时，场景服务也需要读写每个玩家的部分数据。</p>\n\n<p>即使对数据做精心的划分：分为玩家私有数据（例如背包）和玩家交互数据（例如玩家的战斗 buf ，属性等），把它们分开存放在 agent 和场景服务中。依然也有一定的需求两类数据间发生交互。</p>\n\n<p>如果我们在设计上能保证一组数据是存在一个写入者，其它服务都是读取者，我们可以把数据放在拥有写入权的地方，而其它地方都是这份数据的副本。</p>\n\n<p>数据体和数据副本间的同步就可以利用上面这个模块。</p>\n\n<p>在分布式系统中，不存在完全的状态同步，但共享状态需要保证版本的原子性，也就是说如果你的一次数据修改若涉及多个字段，那么需要保证读取方每次都读到这组数据不同字段的同一个版本，而不能是 a 是上个版本， b 是下个版本。</p>\n\n<p>如果采用这个模块，我们可以定期对数据表做 commit ，生成差异集发送到副本所在的服务，让它每次都原子性的 patch 差异集。这样持有副本方就一定能保证读到的是一个完整的版本了。至于版本落后数据源一小段时间，则是在设计范畴内的了。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1034+http://blog.codingnow.com/2017/02/tracedoc.html"}, {"summary": "<p>昨天在 review 我公司一个正在开发的项目客户端代码时，发现了一些坏味道。 客户端框架创建了一个简单的对象系统，用来组织客户端用到的对象。这些对象通常是有层级关系的，顶层对象放在一个全局集里，方便遍历。通常，每帧需要更新这些对象，处理事件等等。 顶层每个对象下，还拥有一些不同类别的子对象，最终成为一个森林结构，森林里每个根对象都是一颗树。对象间有时有一些引用关系，比如，一个对象可以跟随另一个对象移动，这个跟随就不是拥有关系。 这种设计方法或模式，是非常常见的。但是在实现手法上，我闻到了一丝坏味道。...</p>", "title": "一个简单的 lua 对象回收再利用方案", "published": [2017, 1, 23, 5, 46, 14, 0, 23, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/01/lua_typesystem.html", "content": "<div><p>昨天在 review 我公司一个正在开发的项目客户端代码时，发现了一些坏味道。</p>\n\n<p>客户端框架创建了一个简单的对象系统，用来组织客户端用到的对象。这些对象通常是有层级关系的，顶层对象放在一个全局集里，方便遍历。通常，每帧需要更新这些对象，处理事件等等。</p>\n\n<p>顶层每个对象下，还拥有一些不同类别的子对象，最终成为一个森林结构，森林里每个根对象都是一颗树。对象间有时有一些引用关系，比如，一个对象可以跟随另一个对象移动，这个跟随就不是拥有关系。</p>\n\n<p>这种设计方法或模式，是非常常见的。但是在实现手法上，我闻到了一丝坏味道。</p>\n\n        <p>由于类别很多，所以代码中充斥着模仿静态语言如 C++/C# 般的大量构造和析构函数。我一直对同事说 <a href=\"http://blog.codingnow.com/2008/08/lua_is_not_c_plus_plus.html\">Lua 不是 C++</a> 大部分同事也认同我的观点，但落到实处，却逃不出过去的很多经验。</p>\n\n<p>比如在这次具体问题上，为什么要实现一套带构造和析构函数的类别系统呢？核心驱动力是因为大部分逻辑对象是和场景关联在一起的，并且引用了 U3D Engine 中的 C# 对象，依赖 lua 的 gc 系统去回收资源延迟太大。而往往大部分时候，我们都可以明确的知道一个对象从场景中移除，几乎没有别的地方在引用它，所以需要立刻释放资源。</p>\n\n<p>而临时对象很多，设计人员又想实现一套对象的 table 再利用的方案，让释放掉的对象在可能的情况下，能重新在新创建对象时再利用起来，减少 lua gc 的负担。</p>\n\n<p>为了做到这点，代码框架模仿了 C++/C# 中的常见手法，在构造函数里建立对象的层级关系（子对象有一个叫 owner 的域指向父对象），在析构函数里调用其拥有的对象的 ondestroy 函数，一级级回收。对于非拥有关系，比如前面举例的 follow ，再给出 unfollow 函数用于解除引用。</p>\n\n<p>最终的结果是，每个新的类中，都有十几行雷同的代码做这些枯燥的事情，而且还偶发 bug 。bug 主要出现在一些引用关系没有解对，引用了死对象（当对象被重用时，就错误引用了新对象），或是不该释放的对象被提前释放了，等等。</p>\n\n<p>我认为在代码基中出现大量雷同的、和具体业务不相关的代码，还分布在不同的源文件中，这是极坏的味道：因为它相当于制定了一套复杂的约定，让开发人员遵守，而且这些机械性的代码内聚性很低，容易出错。</p>\n\n<hr>\n\n<p>让我们重新分析一下需求。</p>\n\n<p>核心问题是：对象的频繁生成和释放在实际测试中已经出现了问题：过多的占用临时内存，以及引擎内资源未能及时释放。</p>\n\n<p>围绕这点，设计出来的框架的味道不太好，没有充分发挥 lua 的动态特性。</p>\n\n<p>而实际上，我们需要的一个工作在 lua 虚拟机中的，更小集合的对象生命期管理系统。这套系统最好是内聚性高，不要侵入真正的业务代码，它能正确的管理对象树和弱引用（类 follow）关系。</p>\n\n<p>针对它，我重新设计了一套简单的类型系统。这套系统支持开发人员预定义对象类型，把引用关系描述在类型定义中，并适当的留出简单成员变量的位置。让对象在释放后，可以尽可能的复用数据结构，避免重复构造新的表，依赖 gc 回收临时表。</p>\n\n<p><a href=\"https://github.com/cloudwu/luatypesystem\">我大约花了 200+ 行代码来实现它</a>。</p>\n\n<p>比如在 test.lua 中我定义了这样一个类型：</p>\n\n<pre>\nts.foo {\n    _ctor = function(self, a)\n        self.a = a\n    end,\n    _dtor = function(self)\n        print(\"delete\", self)\n    end,\n    a = 0,\n    b = true,\n    c = \"hello\",\n    f = ts.foo,\n    weak_g = ts.foo,\n}\n</pre>\n\n<p>这个类型名叫 foo ，它描述了 a b c 三个简单类型的成员，分别是数字、布尔量、和字符串。并定义了默认值 0 true \"hello\" ，它们将在构造函数之前被赋值成默认值。</p>\n\n<p>其中还定义了 f 和 g 两个引用成员。f 是一个强引用，引用类型也是 foo ；g 是一个弱引用，用 weak_ 前缀修饰。</p>\n\n<p>我们可以为 foo 定义出构造函数 ctor ，这个 ctor 会传入 table self ，使用者不必关系 self 从哪里来，到底是新构造的表，还是过去释放的对象的表的再利用。框架会保证在 ctor 被调用前，其成员都赋值为默认值；其中的引用变量都将被赋为 false ，可以在构造函数里进一步赋值。注：这里是 false 不是 nil ，是希望可以在 self 中保留一个 slot 。</p>\n\n<p>框架不会给 self 附加 metatable ，这样对使用者最为灵活，如果需要，可以在 ctor 中加上自己需要的 metatable 。</p>\n\n<p>构造 foo 类的对象可以调用 ts.foo:new(...) ，它将在框架内的 root 集内添加一个新的 foo 对象，并返回。</p>\n\n<p>如果想继续构造 foo 下的 f ，可以使用 <code>f._ref.f(...)</code> 。这个函数调用会调用对应的构造函数，并不需要指明构造类型，这是因为类型定义中已经指明了 foo.f 的类型。</p>\n\n<p>这里使用了一个比较奇怪的语法：<code>f._ref.f</code>  ，我们应该理解成对 f.f 的引用进行改写操作。这里并没有对 foo 对象设置 metatable 来提供更漂亮的语法糖，这是因为希望把 metatable 的弹性留给使用者。而且明确写 <code>对象._ref.字段</code> 可以显示的提示这段代码将对 “对象.字段” 的引用进行修改。</p>\n\n<p>修改引用，让其引用到一个新对象可以用 <code>f._ref.g = f</code> 。这会把 f 的一个弱引用赋给 f.g 。强引用也能这样写 <code>f._ref.f = f</code> 。</p>\n\n<p>那么，写 <code>f._ref.f = ts.foo:new(...)</code> 和写 <code>f._ref.f(...)</code> 有什么区别呢？</p>\n\n<p>前者通过调用 ts.foo:new 构造出一个 foo 对象，然后赋给了 f.f 。但是它会在 root 集内也添加一个这个新对象，当日后从 root 集移除 f 时，这个新对象依旧被 root 集引用。</p>\n\n<p>而后者也是构造了一个新的 foo 对象赋给 f.f ，但它不会在 root 集添加这个对象，并且新对象中会自动生成一个 .owner 字段指向 f 。</p>\n\n<p>如果想清除一个引用，可以写 <code>f._ref.f = nil</code> 。不过再次读 f.f 的时候，会发现值是 false 而不是 nil 。这是为了在数据结构中保持一个 slot ，也可以确保用户加的 metatable 可以正确工作。</p>\n\n<p>如果只想用读取 f 下属对象，就直接写 f.f 或 f.g 即可。不过这里 g 是一个弱引用，所以通常使用前应该做一次判断 if f.g then ... end 。</p>\n\n<hr>\n\n<p>从 root 集移除一个对象，可以用 ts.delete(f) 。但是这个 delete 操作绝对不会触发对象的终结函数 dtor ，它做的仅仅是把对象从 root 集中移除。</p>\n\n<p>上面反复谈到了 root 集。这是个很有用的集合，比如，你可以简单理解为，它就是场景，而构造出来的对象都默认放在了场景中。</p>\n\n<p>我们可以用 for obj in ts.each() do ... end 来遍历这个集合，取出所有的对象处理。也可以单独删选一种类型的对象遍历： for obj in ts.each(ts.foo) do ... end 。</p>\n\n<p>当一些对象移除 root 集，或是对象树内部的引用关系改变后，你可以调用 ts.collectgarbage() 来寻找哪些对象已经不再被引用，框架会用一个 mark-sweep 算法把不再被 root 集引用的对象回收再利用。在回收前，如果对象有 dtor ，也会调用。</p>\n\n<hr>\n\n<p>另外，每个对象都有一个唯一的数字 id ，可以用 obj._id 获得。及时对象被收回，id 也不会重复。所以、当你在这个系统外想引用系统内的对象时，就应该用 id 来保持一个弱引用。之后，可以通过 ts.get(id) 来转换为真正的对象。如果对象已经被回收， ts.get 会返回 nil 。</p>\n\n<p>ts.type(obj) 可以获得一个对象的类型名字，如果对象不是这个系统内的对象，则返回 nil 。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1033+http://blog.codingnow.com/2017/01/lua_typesystem.html"}, {"summary": "<p>网游里有很多抽卡、开箱子之类的赌性玩法，在最开始，游戏设计者实现的时候，仅仅给这些抽取概率简单的设置了一个值。比如抽卡抽出橙卡的概率是 10% ，那么就是说，玩家每次抽一张卡，有 90% 的可能是白卡，10% 的可能是橙卡。 但大 R 玩家是大爷，需要小心伺候。如果感受不好，人跑了就亏大了。概率这个东西靠改进伪随机数发生器是解决不了体验问题的，大爷要是连抽 20 张都出不来橙卡，那是要怒删游戏的。 连抽 20 张 10% 概率橙卡一张都抽不到的机会多不？一张抽不中的概率是 0.9 ，20 张都抽不中的概率是 0.9 ^20 = 12.2% 。这可不算小数字啊。平均 8 个大 R 就会碰到一次，一下子赶跑了 1/8 的金主，这个责任小策划可担当不起。 所以、一般网游都会用各种规则来避免玩家出现连抽不中的尴尬。例如，我忘记是谁发明的 10 连抽规则：如果你购买一个大包连抽 10 次，我在规则上就保证里面一定至少有一张橙卡。实现它应该并不困难，按常规概率生成 10 张的卡包，如果里面没有橙卡，那么我加一张即可。...</p>", "title": "10 连抽保底的概率模型", "published": [2017, 1, 16, 13, 53, 10, 0, 16, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/01/exponential_distribution.html", "content": "<div><p>网游里有很多抽卡、开箱子之类的赌性玩法，在最开始，游戏设计者实现的时候，仅仅给这些抽取概率简单的设置了一个值。比如抽卡抽出橙卡的概率是 10% ，那么就是说，玩家每次抽一张卡，有 90% 的可能是白卡，10% 的可能是橙卡。</p>\n\n<p>但大 R 玩家是大爷，需要小心伺候。如果感受不好，人跑了就亏大了。概率这个东西靠改进<a href=\"http://blog.codingnow.com/2007/11/random.html\">伪随机数发生器</a>是解决不了体验问题的，大爷要是连抽 20 张都出不来橙卡，那是要怒删游戏的。</p>\n\n<p>连抽 20 张 10% 概率橙卡一张都抽不到的机会多不？一张抽不中的概率是 0.9 ，20 张都抽不中的概率是 0.9 ^20 = 12.2% 。这可不算小数字啊。平均 8 个大 R 就会碰到一次，一下子赶跑了 1/8 的金主，这个责任小策划可担当不起。</p>\n\n<p>所以、一般网游都会用各种规则来避免玩家出现连抽不中的尴尬。例如，我忘记是谁发明的 10 连抽规则：如果你购买一个大包连抽 10 次，我在规则上就保证里面一定至少有一张橙卡。实现它应该并不困难，按常规概率生成 10 张的卡包，如果里面没有橙卡，那么我加一张即可。</p>\n\n        <p>但如果我想把 10 抽保底的规则惠及日常抽卡的玩家该怎么做呢？</p>\n\n<p>就是说，我希望任何玩家任何时候，接连抽了 10 张卡，我都想保证这 10 张卡里至少有一张橙卡。</p>\n\n<p>首先，要说明的一点：如果你同时想保证橙卡掉落率是 10% ，也就是在极大范围内，比如系统投放了一万张卡片中，其中要有一千张橙卡。那么同时保证每 10 张卡里有至少一张橙卡的话，结果一定是完全不随机的，也就是必须每抽 9 张白卡，必出一张橙卡。</p>\n\n<p>所以、如果即想要随机（出橙卡的概率稳定），又想有 10 张出一张的保底，那么橙卡投放量是一定超过 1/10 的。</p>\n\n<p>我们之前的游戏用了个很粗暴的方案：记录玩家已经连续几次没有抽中，如果连续次数超过 9 ，就必给他一张橙卡。为什么我说这个方案粗暴，因为它其实破坏了抽卡的自然体验。虽然玩家的确更高兴了，但是概率却很不自然。不自然的方案（其实是生硬的打了个补丁）实现起来还容易出错，我们前段时间就因为实现 bug 多发放了很多稀有物品，这个 bug 就不展开说了。</p>\n\n<p>下面来看看，为什么这么做不自然。</p>\n\n<p>假设橙卡的掉率是 10% ，那么你在获得一张橙卡后，再抽下一张橙卡的概率就是 0.1 。下一张是白卡，再下一张是橙卡的概率是 0.9 * 0.1 ，下两张是白卡，第三张是橙卡的概率是 0.9^2 * 0.1 ……</p>\n\n<p>后续有 10 张及 10 张以上的概率总共有多少呢？我算了一下，大约是 35% 左右。</p>\n\n<p>我们把抽到两张橙卡之间会抽取到的白卡张数排成一个数列的话，这个数列的值的范围是 0 到正无穷。是的，非洲酋长可能永远抽不到橙卡。当然这只是理论值。</p>\n\n<p>如果你读过大学，学的是理工科，没有逃课的话，就应该知道，这个数列是大致符合<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83\">指数分布</a>的。指数分布正是用来表示独立随机事件发生的时间间隔的。</p>\n\n<p>当我们把这个数列中大于 9 的数字都强行改成 9 ，那么 9 的出现频率就陡然跳变，这是极不自然的。（分布不平滑）</p>\n\n<hr>\n\n<p>从一致分布的随机数，转换为指数分布的随机数非常简单。如果你懒得自己推导，那么<a href=\"http://stackoverflow.com/questions/2106503/pseudorandom-number-generator-exponential-distribution\">可以在爆栈网上找到公式</a> 。</p>\n\n<p>让我们回答前面的问题，如果我希望获得一个大约每 10 张卡里出一张橙卡的随机数列，除了每次 random 一个 [0,10) 的整数，判断证书是不是 0 以外，还有一个方法。那就是每次抽到一个橙卡后，都从一个指数分布的随机数列中取一个值出来，作为接下来会抽取到白卡的张数。按这个张数去发放白卡，等计数器减到 0 ，就发一张橙卡给玩家。这个白卡张数的数值范围是 [0, inf) 。</p>\n\n<p>用 lua 实现的话，大概是这样的：</p>\n\n<p><code>math.floor(math.log(1-math.random()) * (-rate))</code> 其中 rate = 10 。</p>\n\n<p>好了，如果我们想加上 10 张保底，又想让间隔大致符合指数分布怎么办？简单：</p>\n\n<pre>\nfunction erand(rate)\n    while true do\n        local p = math.floor(math.log(1-math.random()) * (-rate))\n        if p &lt; rate then\n            return p\n        end\n    end\nend\n</pre>\n\n<p>让产生出来的数字小于 10 的时候重来一次就好了。如果你担心这里死循环（实际并不会），也可以加上循环上限：</p>\n\n<pre>\nfunction erand(rate)\n    for i = 1, 100 do  -- 100 可以随便写\n        local p = math.floor(math.log(1-math.random()) * (-rate))\n        if p &lt; rate then\n            return p\n        end\n    end\n    return rate-1\nend\n</pre>\n\n<p>当然，一旦加上了 10 张保底，单张出橙卡的概率就大大增加了，增加到多少呢？大约是 21%。如果你希望保持 10% 左右的投放率，那么保底张数大约应该设置在 23 张左右。</p>\n\n<hr>\n\n<p>ps. 今天在公司群里讨论这个问题时，雷先生提了这么一个问题，说是可以用来做数值策划的面试题：</p>\n\n<p>已知橙卡的抽取率是 10% ，抽一次卡是 1 块钱；而 10 连抽的包可以帮你按同样概率连抽 10 次，但如果没有抽到橙卡的话，系统会补偿一张橙卡给你，换掉 10 张白卡中的一张。</p>\n\n<p>假设白色一文不值，只有橙卡值钱。</p>\n\n<p>那么请问：这个 10 连抽的包到底价值多少？</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1032+http://blog.codingnow.com/2017/01/exponential_distribution.html"}, {"summary": "<p>云豆两岁的日常： 奶奶：10 点了，豆豆该睡觉了。 豆豆：要听咕哩咕哩。 奶奶：ipad 没电了。 （ipad 电量 1%） 豆豆：ipad 真没电了。 奶奶：听小兔子好吗？ 豆豆：（拧开开关）小兔子不好听。（关上） 豆豆：ipad 没电了、手机也没电了、奶奶唱歌。 奶奶：唱什么？ 豆豆：门前大桥下…… 奶奶：我不记得歌词了。 豆豆：（唱）门前大桥下，游过一群鸭…… 不记得歌词了。 豆豆：奶奶唱，（唱）小燕子、 穿花衣，年年春天来这里～ 奶奶：你不是会唱吗？ 豆豆： 奶奶唱小燕子， 豆豆睡觉。 奶奶：（唱）小燕子 穿花衣 年年春天来这里～ Zzz... 豆豆：奶奶睡着啦。...</p>", "title": "豆豆的日常", "published": [2017, 1, 14, 12, 10, 50, 5, 14, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/01/doudou.html", "content": "<div><p>云豆两岁的日常：</p>\n\n<p>奶奶：10 点了，豆豆该睡觉了。</p>\n\n<p>豆豆：要听咕哩咕哩。</p>\n\n<p>奶奶：ipad 没电了。</p>\n\n<p>（ipad 电量 1%）</p>\n\n<p>豆豆：ipad 真没电了。</p>\n\n<p>奶奶：听小兔子好吗？</p>\n\n<p>豆豆：（拧开开关）小兔子不好听。（关上）</p>\n\n<p>豆豆：ipad 没电了、手机也没电了、奶奶唱歌。</p>\n\n<p>奶奶：唱什么？</p>\n\n<p>豆豆：门前大桥下……</p>\n\n<p>奶奶：我不记得歌词了。</p>\n\n<p>豆豆：（唱）门前大桥下，游过一群鸭…… 不记得歌词了。</p>\n\n<p>豆豆：奶奶唱，（唱）小燕子、 穿花衣，年年春天来这里～</p>\n\n<p>奶奶：你不是会唱吗？</p>\n\n<p>豆豆： 奶奶唱小燕子， 豆豆睡觉。</p>\n\n<p>奶奶：（唱）小燕子 穿花衣 年年春天来这里～ Zzz...</p>\n\n<p>豆豆：奶奶睡着啦。</p></div>", "uuid": "tag:blog.codingnow.com,2017://1.1031+http://blog.codingnow.com/2017/01/doudou.html"}, {"summary": "<p>很多使用 Unity3D 开发的项目，都不太喜欢 C# 这门开发语言，对于游戏开发很多人还是更喜欢 Lua 一些。而 Lua 作为一门嵌入式语言，嵌入别的宿主中正是它说擅长的事。这些年，我见过许多人都做过 U3D 的 Lua 嵌入方案。比如我公司的阿楠同学用纯 C# 实现了一个 Lua 5.2 （用于在 U3D web 控件中嵌入 Lua 语言的 UniLua ）；还有 ulua slua wlua plua xlua ... 数不胜数。我猜测，a-z 这 26 个字母早就用完了。 上面提到的项目的作者不少是我很熟悉的朋友，我们公司现在的 U3D 游戏也由同事自己实现了一套差不多的东西。所以我曾了解过这些方案。但我一直觉得这些方案要么做的过于繁琐，要么有些细节上不太完备，总是手痒想按自己的想法搞搞看。 Mono 和...</p>", "title": "在 Unity3D 的 Mono 虚拟机中嵌入 Lua 的一个方案", "published": [2017, 1, 8, 14, 22, 15, 6, 8, 0], "author": "云风", "url": "http://blog.codingnow.com/2017/01/unity3d_sharplua.html", "content": "<div><p>很多使用 Unity3D 开发的项目，都不太喜欢 C# 这门开发语言，对于游戏开发很多人还是更喜欢 Lua 一些。而 Lua 作为一门嵌入式语言，嵌入别的宿主中正是它说擅长的事。这些年，我见过许多人都做过 U3D 的 Lua 嵌入方案。比如我公司的阿楠同学用纯 C# 实现了一个 Lua 5.2 （用于在 U3D web 控件中嵌入 Lua 语言的 UniLua ）；还有 ulua slua wlua plua xlua ... 数不胜数。我猜测，a-z 这 26 个字母早就用完了。</p>\n\n<p>上面提到的项目的作者不少是我很熟悉的朋友，我们公司现在的 U3D 游戏也由同事自己实现了一套差不多的东西。所以我曾了解过这些方案。但我一直觉得这些方案要么做的过于繁琐，要么有些细节上不太完备，总是手痒想按自己的想法搞搞看。</p>\n\n<p>Mono 和 C 通讯使用 P/Invoke ，用起来不算麻烦，但是要小心暗地里做的 Marshal 的代价，特别是对象传递时装箱拆箱的成本。Lua 和 C 通讯有一套完善的 C API ，但完全正确使用并不容易。核心难点是 Mono 和 Lua 各有一套自己的异常机制，让它们协调工作必须很小心的封装两个语言的边界，不要让异常漏出去。<a href=\"http://blog.codingnow.com/2015/05/lua_c_api.html\">我在 2015 年写过一篇 Blog 做过相关讨论</a> 。</p>\n\n<p>我认为简单且完备的 Mono / Lua 交互方案是这样的：</p>\n\n        <p>当一边要和另一边通讯时，这和 C/S 结构的相互通讯并没有本质区别，都是发送一串数据到对方虚拟机。这种抽象方式要比 Mono 和 C 交互用的 P/Invoke 或是 Lua 的一堆 C API 要简洁的多。通常说来，一切的跨虚拟机通讯，都仅可以看成是一次异地函数调用。只要约定发送的数据串的第一项是一个函数，而后续内容是调用的参数即可。</p>\n\n<p>所以 Mono 和 Lua 的交互方案就简化成了，如何从一边发送一串数据，这串数据中可以包含两边都认可的基本数据类型，如数字、字符串、布尔量，也可以包含某个虚拟机中的对象。我们并不需要真的把本地的一个对象的数据内容全部序列化成串发送给对端，而只需要给将发出的本地对象附上一个数字 id ，对端记录下 id ，等后面真的需要操作这个远程对象时，再将 id 发送回去即可。</p>\n\n<p>要调用的函数本身也是一个本地对象。对于 Lua ，函数本来就是 first class 的，而 Mono 这边则可以统一给一个 Delegate 来做此媒介。</p>\n\n<p>以 Mono 调用 Lua 为例，我们用事先获取到的 Lua 函数对象 id ，加上调用参数，将这一系列数据组织在一个不需要特别做 Marshal 的 struct 中，把这个 struct 通过 P/Invoke 传给 C 层；然后 C 函数调用一个写好的 Lua 函数把 struct 的内容置入 Lua VM 。然后在 Lua VM 中，用事先定义好的流程去处理它，通常的处理方式就是将第一个函数对象压栈，用后面的数据做参数调用它。最后，取得函数调用的返回值，再将返回值编码成 Mono 可操作的 struct 返回。</p>\n\n<p>之所以是通过一个 struct 转换，而不是像很多别的封装方案那样把 lua 的 C API 导成 C# 的 API 直接操作 Lua 虚拟机。是因为从设计层面看，我们需要提高这个模块的内聚性，让和 Lua 交互层和 Mono 有最少的接口（减少耦合）。另，Lua 的 API 原本是供 C 使用的，对于异常处理有一套独特的规则；而掺入 Mono 这个东西后，我们又需要异常不外溢。把 struct 压入 Lua 虚拟机的过程可以用唯一一个 lua 函数做到，更方便限制住任何可能产生的异常。</p>\n\n<p>Lua 调用 Mono 会稍微麻烦一点，需要定义一个 Delegate ，然后再把需要调用的 C# 函数/类等都按此 Delegate 做一些封装。好在 C# 有完善的反射机制来做这件事，若想提高效率的话，还可以有别的优化手段，比如为需要导出的类做代码生成。因为嵌入 Lua 的目的是将多变的业务放到更灵活的 Lua 语言中去编写，而 C# 这边的代码相对固定，在项目中后期基本不会有太多变化，这些优化手段都是值得在项目前期进行的。</p>\n\n<p>注：这里从 Mono 返回字符串部分要小心处理。因为 Mono 向外传递字符串有额外的开销，最好能做到不传字符串时，可以没有这个开销。</p>\n\n<hr>\n\n<p>这个周末，我花花整整一天的时间来实现上面的想法。<a href=\"https://github.com/cloudwu/sharplua\">代码放在了 github 上</a> 。它可以在 mono 上编译运行，暂时没有文档，但是整个结构很简单，使用范例在 test.cs 里也基本展示出来了。</p>\n\n<p>这里花去不少篇幅完成的工作是两个不同虚拟机间的对象相互引用。之前在 <a href=\"https://github.com/Tencent/xLua/issues/14\">xlua 的项目 issue 中做了一些讨论</a> 。</p>\n\n<p>一个虚拟机的对象，如果传递到另一边，需要在本地做一个强引用，防止被 gc 掉。当对方不再使用这个对象后，可以解除这个强引用。对于远程对象，在本地都是记录一个 id 。Lua 和 C# 都有发现一个对象不再使用的能力，Lua 利用的是弱表，C# 有 Weak Reference 。以 Lua 为例，我们将远程对象放在弱表中，以 id 去索引；同时再把远程对象的 id 都收集在一个集合里。只需要定期检查 id 集合中有哪些 id 于弱表中查询不到了，它们就是不再使用的远程对象。</p>\n\n<p>固然，还可以用 <code>__gc</code> 方法在远程代理对象被回收时获知信息，但我并不推荐这种做法。加上 <code>__gc</code> 方法会为 gc 流程增加许多不必要的负担，而且这些方法的调用时机很难主动掌控，最终你还是只会在 <code>__gc</code> 方法中登记一下 id ，和上面提到的主动比对弱表的方案并没有获得任何好处。</p>\n\n<p>真正难处理的地方在于两个虚拟机间对象的循环引用。</p>\n\n<p>假设 mono 中有一个对象 A 被传递到 Lua ，Lua 中为之生成了代理 A' ；Lua 中有另一个对象 B 传递给 Mono ，Mono 为之生成了代理对象 B' 。</p>\n\n<p>如果 mono 中 A 引用了 B' ，同时 Lua 中 B 引用了 A' ，则造成了循环引用。由于 Lua 中的 A' 不回收的话，Mono 不能回收 A ；同理 Mono 中的 B' 不回收的话， Lua 中也会一直持有 B 的强引用。所以 A B 两个对象即使没有任何别的地方使用它们了，也无法被回收掉。</p>\n\n<p>回收这类循环引用的对象也并非没有办法。如果虚拟机具备一种能力，可以获知一个对象是否只被特定东西（在这里指外部虚拟机）引用住，那么就可以很简单的解决这个问题。</p>\n\n<p>当 Mono / Lua 发现，某些对象仅存在外部引用，那么就将这些对象设置成一个特殊状态（可以是引用次数加一，也可以是放在一个特殊集合中）；一旦某个对象被设置了两次特殊状态（双方都不再引用），就可以真的清除它们。</p>\n\n<p>我对 C# 不太熟悉，不知道如何做到这点；但 Lua 做这件事情非常容易。</p>\n\n<p>一种方法是，自己遍历虚拟机，但不遍历导出对象的集合，所有没有遍历到的，但存在于这个集合中的对象，就是仅有外部引用的。遍历虚拟机对 Lua 来说不是难事，我在两个过去的项目中分别用 <a href=\"http://blog.codingnow.com/2016/11/lua_update.html\">Lua</a>  和 <a href=\"http://blog.codingnow.com/2012/12/lua_snapshot.html\">C</a> 各实现过一遍。</p>\n\n<p>还有一种取巧的方法需要利用 Lua 的 <a href=\"http://blog.codingnow.com/2016/09/ephemeron_table_property_tables.html\">ephemeron table</a> 。当我们需要检测一个对象是否只有外部引用时，可以先把它从引用表里移除，移到一个 ephemeron table 中。这个 table 的结构是 obj : { obj } 这个样子。对于 { obj } 这个 value 可以加上 <code>__gc</code> 方法。如果 obj 没有额外的引用，那么 <code>__gc</code> 会被调用。我们可以把 obj 移到另一个叫做坟场的 table 中复活。这样 obj 就没有真的被清理掉了。</p>\n\n<p>不过采用这个方法时，要特别留意 weak table (ephemeron table) 在工作时，会让<a href=\"http://blog.codingnow.com/2016/11/cache_data.html\">暂时移除的 obj 处于一种中间状态</a> ，即不在 weak table 中，<code>__gc</code> 也还没有被调用，也就是没来得及移到坟场。</p>\n\n<p>仅使用 Lua 这种检测能力，就足以消除循环引用。当我们找到只有外部引用的对象，就可以认为在当次 gc 循环结束后，这批对象没有内部引用了，它们只有外部引用，且相互间可能有联系（即前面说的， A B 间有循环引用）。</p>\n\n<p>这批对象暂时不能从 Lua 中删除，因为 C# 一侧可能还持有它们的引用，日后会访问它们。但 Lua 中目前已经没有引用了，可以把这些对象的删除请求发送给 Mono 。Mono 收到后，可以解除这批对象的外部引用（解开循环引用），等待 GC 工作；如果其中有对象真的被回收，再通知 Lua 真的删除掉。如果 C# 还在继续引用，则通知 Lua 把对象全部从坟场取回。</p>\n\n<p>方案细节在前面给出的 issue 中已经讨论的足够多了，这里不再展开。</p>\n\n<hr>\n\n<p>我们真的需要这么细致的管理双向引用么？</p>\n\n<p>在我们自己的项目中，并没有做这些复杂处理。这是因为，一旦在 C# 中加入 Lua ，就暗示着把业务逻辑搬到了 Lua 中写。在 Mono 和 Lua 两边都存在业务逻辑且交叉引用的情况本身就是很不合理的。更多的情况是，Mono 负责和引擎底层沟通，所有的引擎对象都是由 Lua 通过中间城命令 C# 去创建的；当 Lua 层不再使用这些对象后，再通知删除。C# 本身并没有业务层去引用这些对象。Lua 和 C# 应该是应该上下层清晰的关系，而不应该是混杂在一起的并列关系。</p>\n\n<p>所以我推荐的做法是，只有 Lua 可以长期持有 Mono 中的 C# 对象，而 Mono 中只可以短期持有 Lua 层的对象（不超过游戏中的一帧）。这样，Lua 就有权利主动清理那些自己并不持有的本地对象而不需要通知 Mono 了，这种单边关系便不会产生循环引用。</p>\n\n<p>Mono 中唯一可能长期持有的 Lua 对象唯有一些重要的回调函数，比如在每个游戏逻辑帧内都去调用一次 Lua 里定义好的 update 函数。而这种 Lua 函数对象，只需要让 Lua 自己长期保有引用（比如放在全局表里）就可以了。</p>\n\n<p>即使真的想做出一套完备的 Mono 和 Lua 间的对象双向引用关系，我也推荐用最简单的方案，基础方案中不去考虑循环引用的问题。而可以单独写一个模块来解开潜在的循环引用，这个模块性能不是主要考虑问题，在合适的时候（比如 loading 场景时）启动检查即可。</p>\n\n<hr>\n\n<p>最后简单说说我周末实现的这套 sharplua 。它提供了在 Mono 中创建出一个 Lua 虚拟机，并可以从 C# 调用 Lua 函数，获取返回值的能力。同时，Lua 代码中也可以调用由 C# 注入的 C# 函数。</p>\n\n<p>SharpLua 类即对应一个 lua 5.3 虚拟机，需要传入第一个 lua 文件名启动它。这个 lua 文件中必须 require \"sharplua\" 这个模块，辅助完成初始化工作。sharplua 这个 lua 模块中有部分是用来管理 mono 和 lua 间数据交换的内部函数，供底层工作时使用；还有一些提供给 lua 业务层使用的 api ，方便回调 C# 函数。</p>\n\n<p>C# 这边只有三个 API 用来和 Lua 通讯。</p>\n\n<p>可以通过 SharpLua.GetFunction 从 Lua 虚拟机的全局表中获得一个以字符串命名的全局函数。这是一切逻辑的起点。之所以不提供更多的获取 Lua 内部数据的 C# API 是因为，其他的需求都可以通过你自己写一个 Lua 全局函数来完成，C# 只需要调用它就可以了。</p>\n\n<p>SharpLua.CallFunction 可以用来调用一个 Lua 函数，携带任意参数，可获得任意返回值。为了实现简单，这里限制了一次函数调用最多传 255 个参数，返回值不能超过 256 个。</p>\n\n<p>注意，返回值也可以是一个 Lua 函数对象。所以你可以写一个 Lua 全局函数来返回 Lua 虚拟机中的其它函数。而参数则可以是任意对象，除了数字、字符串等这些 Mono 和 Lua 都有的基本类型外，还可以传入之前的获取的 Lua 对象以及 C# 的任意 Class 对象。这里约定了一种指定的 Delegate ，一旦把它传个 Lua ，Lua 可以通过 sharplua.call 来回调它，从而可以做到 Lua 向 C# 通讯。具体用法可以参考 test.cs ，虽然这里是手写了一个 Delegate 供 Lua 调用，但是你可以继续完善它，比如使用 C# 的反射能力去间接调用任何你想调用的 C# 函数，也可以为 C# 类做一些代码生成工作，生成函数以这个 Delegate 的形式注入 Lua 。</p>\n\n<p>最后一个 API 是 SharpLua.CollectGarbage 。它会从 Lua 虚拟机中收集那些曾经传给 Lua 的 C# 对象中，哪些 Lua 已经不再使用，好让 Mono 这边可以解除引用让 Mono 的 GC 可以正确工作以回收掉它们。</p>\n\n<p>SharpLua 它整个实现简单易读，对外接口也很少。稍加封装，就可以嵌入 Unity3D 中使用。如果有同学有兴趣继续完善，欢迎提 PR 。</p>\n\n<hr>\n\n<p>有几点是可以继续做的。</p>\n\n<ol>\n<li><p>C# 的字符串最好能 marshal 成 Unicode ，然后在 Lua 里转换成 utf8 ；还有相关的反向处理。</p></li>\n<li><p>在 marshal 字符串的时候，如果发现是短字符串，可以在 mono 和 lua 间同步一张不太大的字符串表，只在第一次传递的时候对 string 做 marshal ，之后相同的字符串都查表传 id ，减轻 string 传递的负担。</p></li>\n</ol></div>", "uuid": "tag:blog.codingnow.com,2017://1.1030+http://blog.codingnow.com/2017/01/unity3d_sharplua.html"}, {"summary": "<p>U3D 的打包流程，谁用谁知道。 由于输出 ios 包必须在 xcode 环境，跑在 Mac 系统上，所以为了定期版本打包，我们采购了配置比较高的垃圾桶来做。一台大约要三万 RMB 左右。 但我觉得这个方案的性价比太低了。 经过简单的考察，我发现，打包流程中最慢的环节是贴图压缩。在不同的平台，需要把原始贴图文件压缩成对应平台的压缩贴图格式： ios 平台对应的是 PVR 压缩格式；Android 平台对应的是 ETC 压缩格式，等等。 u3d 自己也意识到压缩贴图太慢，所以官方给出了一个 CacheServer 方案。...</p>", "title": "用分布式压缩贴图加快 Unity3D 的打包过程", "published": [2016, 12, 12, 6, 5, 49, 0, 347, 0], "author": "云风", "url": "http://blog.codingnow.com/2016/12/unity3d_remote_pvrtextool.html", "content": "<div><p>U3D 的打包流程，谁用谁知道。</p>\n\n<p>由于输出 ios 包必须在 xcode 环境，跑在 Mac 系统上，所以为了定期版本打包，我们采购了配置比较高的垃圾桶来做。一台大约要三万 RMB 左右。</p>\n\n<p>但我觉得这个方案的性价比太低了。</p>\n\n<p>经过简单的考察，我发现，打包流程中最慢的环节是贴图压缩。在不同的平台，需要把原始贴图文件压缩成对应平台的压缩贴图格式： ios 平台对应的是 PVR 压缩格式；Android 平台对应的是 ETC 压缩格式，等等。</p>\n\n<p>u3d 自己也意识到压缩贴图太慢，所以官方给出了一个 CacheServer 方案。</p>\n\n        <p>本质上 CacheServer 只是一个文件 cache 服务器，它记录了用贴图原文件和转换参数（u3d 的 meta 文件）以及转换器版本等信息构成的串的 md5 值作为文件的索引。</p>\n\n<p>第一个做转换的人，在本地压缩完毕后，会将结果上传到 CacheServer ，然后后面的人需要做相同的压缩时，去 CacheServer 查找是否之前有人做过同样的工作，避免重复操作。</p>\n\n<p>当源文件相同、转换参数也完全一样时，结果会被缓存。由于日常几乎所有贴图都被人压缩过，这样极大的减少了定期打包的时间。</p>\n\n<hr>\n\n<p>CacheServer 的设计虽然简单，却不能最好的解决问题。实际打包时，还是需要很长的时间。这是因为，定期打包需要输出各个平台的包，而日常开发只会稳定在一个平台上。比如日常工作使用的都是 Android 平台的话，等打 ios 包时，依旧需要压缩 pvr 贴图。</p>\n\n<p>CacheServer 只做结果缓存，所以不可能在 Server 那里针对源图自动做多个版本的压缩格式；而且它保存的是转换参数的 hash 值，丢失了参数信息。btw，它的实现也是非常粗糙的。</p>\n\n<p>U3D 转换图片的另一个问题是，导入贴图时会在本地机器上进行大量的贴图压缩工作，这个工作是极耗 CPU 的，把工作机卡上几秒不能动弹是常用的事，非常影响工作心情。</p>\n\n<p>综上，我想实现一个远程压缩贴图的方案。</p>\n\n<p>U3D 调用的是一个叫作 PVRTexTool 的命令行工具压缩贴图的。这是 PowerVR 公司提供的官方工具，幸运的是，它有 Linux 版本。这样我们就可以有办法用廉价的 linux 服务器来做这件事情，而不必采购昂贵的 Mac 垃圾桶。</p>\n\n<p>最简单的方案是替换掉本地的 PVRTexTool 命令行工具，将源贴图上传到远程服务器，然后远程调用该工具压缩贴图，最后再把结果文件传回来。</p>\n\n<p>做过改造之后，打包流程中最消耗 CPU 的工作就被转移走了。经过简单的测试，配合一个性能并不算强的 8 核服务器辅助压缩贴图，在 Mac Mini 上打包也可以比 4 核的垃圾桶工作站快上 30% 。而实际使用时，可以用采购垃圾桶一半的钱买到性能高几倍的 32 核服务器。</p>\n\n<p>更重要的是，这个远程打包服务，还记录了每次压缩贴图请求的原始图片和压缩参数。我们可以写一个脚本，安排在夜间运行，找出白天提交的压缩请求，把命令行中的 -f 参数换掉（控制生成何种平台的压缩格式），为每个平台的压缩格式都生成一次。这可以解决只用 CacheServer 不能自动生成全平台压缩贴图的问题。</p>\n\n<p>除了打包机外，开发人员的桌面开发机也可以部署这个工具，提高导入图片的使用体验（不再依靠本地工具压缩图片，不会因为导入贴图而卡住工作机）。</p>\n\n<hr>\n\n<p>我花了一个周末用 skynet 实现了这么一个小工具。<a href=\"https://github.com/cloudwu/remotepvrtool\">在我的 github 仓库里可以找到</a> 。由于是自己使用，所以并不想写部署说明，也不打算解答使用上的问题。如果有游戏公司想用又不想自己折腾，可以提供一次性的付费技术支持服务。</p></div>", "uuid": "tag:blog.codingnow.com,2016://1.1029+http://blog.codingnow.com/2016/12/unity3d_remote_pvrtextool.html"}, {"summary": "<p>写备注总有时候光靠文字描述不是很清楚，这个时候特别想在文档中附个关系图。用 graphviz 的 DOT 来描述图固然不错，但是它需要额外工具来生成才能直观的查看。如果我们想在纯文本环境附上插图，使用 ascii art 是最佳选择。 我搜了一下，perl 的 Graph::Easy 是唯一能找到的支持 ascii 输出的关系图绘制软件。 但是这个东西有个问题，就是对中文支持不行，虽然文档中说完全支持 Unicode ，但显然作者并没有把汉字用在 Ascii 输出上过。...</p>", "title": "用 Ascii 画关系图", "published": [2016, 12, 6, 12, 50, 40, 1, 341, 0], "author": "云风", "url": "http://blog.codingnow.com/2016/12/ascii_graph.html", "content": "<div><p>写备注总有时候光靠文字描述不是很清楚，这个时候特别想在文档中附个关系图。用 <a href=\"http://www.graphviz.org/\">graphviz</a> 的 DOT 来描述图固然不错，但是它需要额外工具来生成才能直观的查看。如果我们想在纯文本环境附上插图，使用 ascii art 是最佳选择。</p>\n\n<p>我搜了一下，perl 的 <a href=\"http://bloodgate.com/perl/graph/manual/index.html\">Graph::Easy</a> 是唯一能找到的支持 ascii 输出的关系图绘制软件。</p>\n\n<p>但是这个东西有个问题，就是对中文支持不行，虽然文档中说完全支持 Unicode ，但显然作者并没有把汉字用在 Ascii 输出上过。</p>\n\n        <p>问题是这样产生的：UTF8 中，汉字是 3 字节，而对于显示来说，等宽字体的汉字是 2 倍普通字母宽。这样在排版时，你必须知道一个字符串在视觉上是多宽，才可能用 ascii 字符拼接出正确的方框和连线。</p>\n\n<p>比如，<a href=\"http://www.perlmonks.org/?node_id=713297\">这个帖子就讨论了类似的问题</a> 。</p>\n\n<p>一开始，我希望找到 Graph::Easy 库中取 label 宽度的函数，让它正确返回 label 的视觉宽度。修改后，发现还是不行。这是因为，这个东西在 ascii 输出时，是用一个 2D 的字符数组模拟了虚拟画布（framebuffer）。它认为，framebuffer 上的一个矩形区域，就应该是 w * h 个字符构成的区域。如果想进一步的让它在 framebuffer 上定位正确，还需要修改它计算坐标的地方。可是，写 framebuffer 是一个随机过程，你向左边写一个一个字符，如果是汉字的话，会改变右边的 x 坐标。也就是把右侧所有的字符都挤了一个位置。如果再重排右侧的所有数据代价就太大了，而且它的内部模块也并没有抽象出这样的定位函数。</p>\n\n<p>后来我想到一个取巧的做法，再读取任何 label 串时，都把这个串处理一下，把其中的汉字全部追加一个不可能在正常文本中存在的字符 U+FFFF ，让每个汉字都真的占据两个字符位。这样的字符串处理函数原本就在模块内存在（因为它本身就要去做类似 \\n 的转义），这样就可以让整个排版过程正常了。</p>\n\n<p>接下来要改的是最终把 framebuffer 序列化回字符串的过程，把里面所有的 U+FFFF 都删掉，就可以正确的输出了。</p>\n\n<p>ps. 本来想提个 PR ，但是 github 上的那个仓库似乎不是原作者在维护的， CPAN 上的版本也不知道怎么提 issue ，所以还是自己玩玩就行了吧。</p></div>", "uuid": "tag:blog.codingnow.com,2016://1.1028+http://blog.codingnow.com/2016/12/ascii_graph.html"}], "description": "思绪来得快去得也快，偶尔会在这里停留"}
